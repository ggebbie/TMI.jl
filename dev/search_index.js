var documenterSearchIndex = {"docs":
[{"location":"config/","page":"Configuration","title":"Configuration","text":"CurrentModule = TMI","category":"page"},{"location":"config/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"config/","page":"Configuration","title":"Configuration","text":"Reading input files and configuration for TMI.","category":"page"},{"location":"config/","page":"Configuration","title":"Configuration","text":"TMI.config_from_nc\nTMI.config_from_mat\nTMI.watermassmatrix\nTMI.matrix_zyx2xyz\nTMI.circulationmatrix\nTMI.boundarymatrix\nTMI.updatelinearindex\nTMI.surfaceregion\nTMI.ncurl\nTMI.maturl\nTMI.config2nc\nTMI.griddicts\nTMI.matfields2nc\nTMI.fieldsatts\nTMI.regions2nc\nTMI.watermassmatrix2nc\nTMI.optim2nc\nTMI.circulationmatrix2nc\nTMI.boundarymatrix2nc\nTMI.grid2nc\nTMI.cartesianindex\nTMI.gridprops","category":"page"},{"location":"config/#TMI.config_from_nc","page":"Configuration","title":"TMI.config_from_nc","text":"function config_from_nc(TMIversion)\nConfigure TMI environment from NetCDF input file.\n\nArguments\n\nTMIversion: TMI version for water-mass/circulation model\n\nOutput\n\nA: TMI steady-state water-mass matrix\nAlu: LU decomposition of A\nγ: TMI grid properties\nTMIfile: TMI file name\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.config_from_mat","page":"Configuration","title":"TMI.config_from_mat","text":"Configure TMI environment from original MATLAB output\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.watermassmatrix","page":"Configuration","title":"TMI.watermassmatrix","text":"function watermassmatrix(file)\nRead and assemble the water-mass matrix.\n\nArguments\n\nfile: TMI NetCDF or MATLAB file name\n\nOutput\n\nA: water-mass matrix\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.matrix_zyx2xyz","page":"Configuration","title":"TMI.matrix_zyx2xyz","text":"    function matrix_zyx2xyz(TMIfile,Azyx,γ)\n\nTransfer zyx format water-mass matrix A to xyz format\n\nArguments\n\nAzyx: water-mass matrix in zyx format\nγ: TMI grid\n\nOutput\n\nAxyz: water-mass matrix in xyz format\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.circulationmatrix","page":"Configuration","title":"TMI.circulationmatrix","text":"function circulationmatrix(file,γ)\nRead and assemble the circulation matrix from MATLAB.\nTransfer to updated x,y,z version\n\nArguments\n\nfile: TMI MATLAB file name\nγ: TMI grid\n\nOutput\n\nL: circulation matrix in xyz format\n\n\n\n\n\nfunction circulationmatrix(file,A,γ)\nRead and assemble the circulation matrix from the efficient storage of A and F₀ variables.\n\nArguments\n\nfile: TMI MATLAB file name\nA: TMI water-mass matrix\nγ: TMI grid\n\nOutput\n\nL: circulation matrix in xyz format\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.boundarymatrix","page":"Configuration","title":"TMI.boundarymatrix","text":"    function boundarymatrix(file,γ)\nRead and assemble the boundary matrix from MATLAB.\nTransfer to updated x,y,z version\n\nArguments\n\nfile: TMI MATLAB file name\nγ: TMI grid\n\nOutput\n\nB: boundary condition matrix\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.updatelinearindex","page":"Configuration","title":"TMI.updatelinearindex","text":"function updatelinearindex(izyx,Izyx,R)\nLinear index translated from z,y,x to x,y,z accounting\n\nArguments\n\nizyx: index of interest in z,y,x accounting\nIzyx: wet Cartesian Index for z,y,x\nR: Linear indices for x,y,z \n\nOutput\n\nixyz: index of interest in x,y,z accounting\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.surfaceregion","page":"Configuration","title":"TMI.surfaceregion","text":" function surfaceregion(TMIversion::String,region::String,γ::Grid)::BoundaryCondition\n\nRead an oceanographically-relevant surface region from NetCDF file. (Also could be read from mat file.)\nReturn a BoundaryCondition\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.ncurl","page":"Configuration","title":"TMI.ncurl","text":"function ncurl(TMIversion)\nplaceholder function to give location (URL) of NetCDF Google Drive input\nin the future, consider a struct or Dict that describes all TMI versions.\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\n\nOutput\n\nurl: location (URL) for download\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.maturl","page":"Configuration","title":"TMI.maturl","text":"function maturl(TMIversion)\nFind *mat file here.\nplaceholder function to give location (URL) of Google Drive input\nin the future, consider a struct or Dict that describes all TMI versions.\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\n\nOutput\n\nurl: location (URL) for download\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.config2nc","page":"Configuration","title":"TMI.config2nc","text":"Save TMI configuration to NetCDF format for non-proprietary access\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.griddicts","page":"Configuration","title":"TMI.griddicts","text":"Save grid dictionaries of attributes for writing to NetCDF file\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.matfields2nc","page":"Configuration","title":"TMI.matfields2nc","text":"Read 3D fields from mat file and save to NetCDF file.\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.fieldsatts","page":"Configuration","title":"TMI.fieldsatts","text":"All variable names and attributes. Useful for writing NetCDF files.\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.regions2nc","page":"Configuration","title":"TMI.regions2nc","text":"Read vectors from mat file, translate to 3D,  and save surface field to NetCDF file.\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.optim2nc","page":"Configuration","title":"TMI.optim2nc","text":"Save optimization parameters to NetCDF file)\n\nFuture considerations: split into 2 functions\n\nread from mat\nsave to nc\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.circulationmatrix2nc","page":"Configuration","title":"TMI.circulationmatrix2nc","text":"Save circulation matrix L to NetCDF file.\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.boundarymatrix2nc","page":"Configuration","title":"TMI.boundarymatrix2nc","text":"Save boundary matrix for transient model to NetCDF file\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.grid2nc","page":"Configuration","title":"TMI.grid2nc","text":"Put grid properties (Cartesian index) into NetCDF file\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.cartesianindex","page":"Configuration","title":"TMI.cartesianindex","text":"function cartesianindex(file)\nRead and assemble the grid coordinates\naccording to the legacy MATLAB code (z,y,x order).\n\nArguments\n\nfile: TMI NetCDF file name\n\nOutput\n\nI: TMI Cartesian index for wet points\n\n\n\n\n\nfunction cartesianindex(wet)\nRead and assemble the grid coordinates\naccording to a 3D tracer in x,y,z order\n\nArguments\n\nwet: BitArray logical mask for wet points\n\nOutput\n\nI: 3D Cartesian indices\n\n\n\n\n\n","category":"function"},{"location":"config/#TMI.gridprops","page":"Configuration","title":"TMI.gridprops","text":"function gridprops(file)\nRead and assemble the grid properties.\n\nArguments\n\nfile: TMI NetCDF file name\n\nOutput\n\ngrid: TMI grid coordinates\n\n\n\n\n\n","category":"function"},{"location":"top/","page":"Top-level functions","title":"Top-level functions","text":"CurrentModule = TMI","category":"page"},{"location":"top/#Top-level-functions","page":"Top-level functions","title":"Top-level functions","text":"","category":"section"},{"location":"top/","page":"Top-level functions","title":"Top-level functions","text":"Main functionality for TMI.","category":"page"},{"location":"top/","page":"Top-level functions","title":"Top-level functions","text":"TMI.trackpathways\nTMI.watermassdistribution\nTMI.regeneratedphosphate\nTMI.volumefilled\nTMI.surfaceorigin\nTMI.meanage\nTMI.sparsedatamap\nTMI.steadyclimatology","category":"page"},{"location":"top/#TMI.trackpathways","page":"Top-level functions","title":"TMI.trackpathways","text":"function trackpathways(TMIversion,latbox,lonbox)\nTrack the pathways of a user-defined water mass.\n Steps: (a) define the water mass by a rectangular surface patch dyed with passive tracer concentration of         (b) propagate the dye with the matrix A, with the result being the fraction of water originating from the surface region.\n See Section 2b of Gebbie & Huybers 2010, esp. eqs. (15)-(17).\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\nlatbox: min and max latitude of box\nlonbox: min and max longitude of box\nγ: TMI grid\n\nOutput\n\nc: fraction of water from surface source\n\n\n\n\n\n","category":"function"},{"location":"top/#TMI.watermassdistribution","page":"Top-level functions","title":"TMI.watermassdistribution","text":"function watermassdistribution(TMIversion,latbox,lonbox)\nTrack the pathways of a user-defined water mass.\n Steps: (a) define the water mass by an oceanographically-relevant surface patch dyed with passive tracer concentration of one\n     (b) propagate the dye with the matrix A, with the result being the fraction of water originating from the surface region.\n See Section 2b of Gebbie & Huybers 2010, esp. eqs. (15)-(17).\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\nAlu: LU decomposition of water-mass matrix A\nregion: name of pre-defined surface region\nγ: TMI grid\n\nOutput\n\ng: water-mass fraction\n\n\n\n\n\n","category":"function"},{"location":"top/#TMI.regeneratedphosphate","page":"Top-level functions","title":"TMI.regeneratedphosphate","text":"function regeneratedphosphate(TMIversion,Alu,γ)\nRegenerated (i.e., accumulated, remineralized) phosphate\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\nAlu: LU decomposition of water-mass matrix A\nγ: TMI grid\n\nOutput\n\nPO₄ᴿ: regenerated phosphate\n\n\n\n\n\n","category":"function"},{"location":"top/#TMI.volumefilled","page":"Top-level functions","title":"TMI.volumefilled","text":"function volumefilled(TMIversion)\nFind the ocean volume that has originated from each surface box.\n This is equivalent to solving a sensitivity problem:\n The total volume is V = vᵀ c , where v is the volume of each box \n and c is the fraction of volume from a given source which\n satisfies the equation A c = d.                     \n Next, dV/d(d) = A⁻ᵀ v, and dV/d(d) is exactly the volume originating from each source.\n\n See Section 3 and Supplementary Section 4, Gebbie & Huybers 2011.\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\nAlu: LU decomposition of water-mass matrix A\nγ: TMI.grid\n\nOutput\n\nvolume: log10 of global ocean volume filled by a surface region, exists at surface, therefore given BoundaryCondition type\n\n\n\n\n\n","category":"function"},{"location":"top/#TMI.surfaceorigin","page":"Top-level functions","title":"TMI.surfaceorigin","text":"function surfaceorigin(TMIversion,loc)\n Find the surface origin of water for some interior box \n This is equivalent to solving a sensitivity problem:\n The mass fraction at a location `loc` of interest is \n`c[loc] = δᵀ c`, where `δ` samples the location of the global mass-fraction variable, c.\nThen the sensitivity of `c[loc]` is: d(c[loc])/d(d) = A⁻ᵀ δ.\nThe derivative is solved using the constraint: Ac = d.\nThe sensitivity is exactly the mass fraction originating from each source.      \nThis problem is mathematically similar to determining how the ocean is filled.\n\nArguments\n\nloc: location (lon,lat,depth) of location of interest\nAlu: LU decomposition of water-mass matrix A\nγ: TMI grid\n\nOutput\n\norigin: surface map of fraction of source water for a given location, log10 of effective depth, in terms of a BoundaryCondition\n\n\n\n\n\n","category":"function"},{"location":"top/#TMI.meanage","page":"Top-level functions","title":"TMI.meanage","text":"function meanage(TMIversion,Alu,γ)\nMean or ideal age\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\nAlu: LU decomposition of water-mass matrix A\nγ: TMI grid\n\nOutput\n\na: mean age [yr]\n\n\n\n\n\n","category":"function"},{"location":"top/#TMI.sparsedatamap","page":"Top-level functions","title":"TMI.sparsedatamap","text":"function sparsedatamap(u₀::Vector{T},Alu,b::BoundaryCondition{T},u::BoundaryCondition{T},y::Vector{T},W⁻,wis,locs,Q⁻,γ::Grid;iterations=10) where T <: Real\n\n Find the distribution of a tracer given:\n (a) the pathways described by A or its LU decomposition Alu,\n (b) first-guess boundary conditions and interior sources given by d₀,\n (c) perturbations to the surface boundary condition u₀\nthat best fits observations, y,\naccording to the cost function,\nJ = (ỹ - y)ᵀ W⁻¹ (ỹ - y)\nsubject to Aỹ = d₀ + Γ u₀.                 \nW⁻ is a (sparse) weighting matrix.\nSee Supplementary Section 2, Gebbie & Huybers 2011.\n\nArguments\n\nu₀:\nAlu:\nb: first guess of boundary conditions and interior sources\ny: observations on 3D grid\nW⁻: weighting matrix best chosen as inverse error covariance matrix\nfg!: compute cost function and gradient in place\nγ: grid\n\n\n\n\n\n","category":"function"},{"location":"top/#TMI.steadyclimatology","page":"Top-level functions","title":"TMI.steadyclimatology","text":"function steadyclimatology(u₀,fg!,iterations)      Find the distribution of a tracer given:      (a) the pathways described by A or its LU decomposition Alu,      (b) first-guess boundary conditions and interior sources given by d₀,      (c) perturbations to the surface boundary condition u₀     that best fits observations, y,     according to the cost function,     J = (ỹ - y)ᵀ W⁻¹ (ỹ - y)     subject to Aỹ = d₀ + Γ u₀.                      W⁻ is a (sparse) weighting matrix.     See Supplementary Section 2, Gebbie & Huybers 2011.\n\nArguments\n\nu₀:\nfg!: compute cost function and gradient in place\niterations: number of optimization iterations\n\n\n\n\n\n","category":"function"},{"location":"plots/","page":"Plots","title":"Plots","text":"CurrentModule = TMI","category":"page"},{"location":"plots/#Plotting","page":"Plots","title":"Plotting","text":"","category":"section"},{"location":"plots/","page":"Plots","title":"Plots","text":"Making plots with TMI.","category":"page"},{"location":"plots/","page":"Plots","title":"Plots","text":"TMI.section\nTMI.planview\nTMI.plotextent\nTMI.sectionplot\nTMI.planviewplot","category":"page"},{"location":"plots/#TMI.section","page":"Plots","title":"TMI.section","text":"function section\nView latitude-depth slice of field\n\nArguments\n\nc::Field, 3D tracer field plus meta data\nlon: longitude of section\n\nOutput\n\ncsection: 2d slice of field\n\n\n\n\n\n","category":"function"},{"location":"grid/","page":"Grid","title":"Grid","text":"CurrentModule = TMI","category":"page"},{"location":"grid/#Grid","page":"Grid","title":"Grid","text":"","category":"section"},{"location":"grid/","page":"Grid","title":"Grid","text":"Handling the grid for TMI.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"TMI.Grid\nTMI.Field\nTMI.cartesianindex\nTMI.linearindex\nTMI.gridprops\nTMI.matrix_zyx2xyz\nTMI.updatelinearindex\nTMI.cellarea\nTMI.cellvolume\nTMI.layerthickness\nTMI.zonalgriddist\nTMI.surfacepatch\nTMI.depthindex\nTMI.lonindex\nTMI.latindex\nTMI.findindex\nTMI.surfaceindex\nTMI.northindex\nTMI.eastindex\nTMI.southindex\nTMI.westindex\nTMI.horizontaldistance\nTMI.interpindex\nTMI.shiftloc\nTMI.interpweights","category":"page"},{"location":"grid/#TMI.Grid","page":"Grid","title":"TMI.Grid","text":"struct Grid\n\nTMI grid with accounting for wet/dry points\n\n\n\n\n\n","category":"type"},{"location":"grid/#TMI.Field","page":"Grid","title":"TMI.Field","text":"struct Field\n\nThis structure permits the grid to be \nautomatically passed to functions with\nthe tracer field.\n\nThis structure assumes the Tracer type to be \nthree-dimensional.\n\ntracer::Array{T,3}\nγ::Grid\nname::Symbol\nlongname::String\nunits::String\n\n\n\n\n\n","category":"type"},{"location":"grid/#TMI.linearindex","page":"Grid","title":"TMI.linearindex","text":"function linearindex(wet)\nRead and assemble the grid coordinates.\n\nArguments\n\nwet: 3D mask for wet points\n\nOutput\n\nR: array of linear indices, but not a LinearIndices type\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.cellarea","page":"Grid","title":"TMI.cellarea","text":"Horizontal area of grid cell\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.cellvolume","page":"Grid","title":"TMI.cellvolume","text":"Volume of each grid cell.\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.surfacepatch","page":"Grid","title":"TMI.surfacepatch","text":"function surfacepatch\nMake a surface boundary condition\nwith a rectangular patch\n\nArguments\n\nlonbox: longitudes of box edges\nlatbox: latitudes of box edges\nγ: TMI.grid\n\nOutput\n\nd: vector that describes surface patch\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.depthindex","page":"Grid","title":"TMI.depthindex","text":"function depthindex(I) \nGet the k-index (depth level) from the Cartesian index\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.lonindex","page":"Grid","title":"TMI.lonindex","text":"function lonindex(I) \nGet the i-index (lon index) from the Cartesian index\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.latindex","page":"Grid","title":"TMI.latindex","text":"function latindex(I) \nGet the j-index (latitude index) from the Cartesian index\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.surfaceindex","page":"Grid","title":"TMI.surfaceindex","text":"function surfaceindex(I) \nGet the vector-index where depth level == 1 and it is ocean.\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.northindex","page":"Grid","title":"TMI.northindex","text":"function northindex(I) \nGet the vector index on the northern open boundary\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.eastindex","page":"Grid","title":"TMI.eastindex","text":"function eastindex(I) \nGet the vector index on the northern open boundary\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.southindex","page":"Grid","title":"TMI.southindex","text":"function southindex(I) \nGet the vector-index on the southern open boundary\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.westindex","page":"Grid","title":"TMI.westindex","text":"function westindex(I) \nGet the vector index on the western open boundary\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.horizontaldistance","page":"Grid","title":"TMI.horizontaldistance","text":"function horizontaldistance(loc,γ)\nreturn the Cartesian index and linear index \nof the nearest N neighbors\n\nArguments\n\nloc: 3-tuple of lon,lat,depth location\nγ: TMI.grid\n\nOutput\n\nhordist: horizontal distance to nearest tracer grid points\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.interpindex","page":"Grid","title":"TMI.interpindex","text":"function interpindex(loc,γ)     Weights for linear interpolation.     The derivative of linear interpolation is needed in sensitivity studies.     ReverseDiff.jl could find this quantity automatically.     Instead we dig into the Interpolations.jl package to find the weights that are effectively the partial derivatives of the function.\n\nArguments\n\nc: a temporary tracer field, would be nice to make it unnecessary\nloc: (lon,lat,depth) tuple of a location of interest\nγ: TMI grid\n\nOutput\n\nδ: weights on a 3D tracer field grid\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.shiftloc","page":"Grid","title":"TMI.shiftloc","text":"function  shiftloc(loc)\n\nsometimes loc longitudes are outside of grid due to different conventions\nassumption: 360° shift is enough to get back on grid\n\n\n\n\n\n","category":"function"},{"location":"grid/#TMI.interpweights","page":"Grid","title":"TMI.interpweights","text":"function interpweights(loc,γ)     Weights for linear interpolation.     The derivative of linear interpolation is needed in sensitivity studies.     ReverseDiff.jl could find this quantity automatically.     Instead we dig into the Interpolations.jl package to find the weights that are effectively the partial derivatives of the function.\n\nArguments\n\nloc: (lon,lat,depth) tuple of a location of interest\nγ: TMI grid\n\nOutput\n\nδ: weights on a 3D tracer field grid\n\n\n\n\n\n","category":"function"},{"location":"legacy/","page":"Older functions","title":"Older functions","text":"CurrentModule = TMI","category":"page"},{"location":"legacy/#Legacy-functions","page":"Older functions","title":"Legacy functions","text":"","category":"section"},{"location":"legacy/","page":"Older functions","title":"Older functions","text":"Older functions for TMI. May be deprecated in the future.","category":"page"},{"location":"legacy/","page":"Older functions","title":"Older functions","text":"TMI.control2state\nTMI.surfacecontrol2field\nTMI.surfacecontrol2field!\nTMI.field2obs\nTMI.E","category":"page"},{"location":"legacy/#TMI.control2state","page":"Older functions","title":"TMI.control2state","text":"function control2state(tracer2D,γ)\nturn 2D surface field into 3D field with zeroes below surface\n\nArguments\n\ntracer2D:: 2D surface tracer field\nwet::BitArray mask of ocean points\n\nOutput\n\ntracer3D:: 3d tracer field with NaN on dry points\n\n\n\n\n\n","category":"function"},{"location":"legacy/#TMI.surfacecontrol2field","page":"Older functions","title":"TMI.surfacecontrol2field","text":"function surfacecontrol2field(usfc,γ.wet)\nturn surface control vector into 3D field with zeroes below surface\n\nArguments\n\nusfc:: surface control vector\nwet::BitArray mask of ocean points\n\nOutput\n\ntracer3D:: 3d tracer field with NaN on dry points\n\n\n\n\n\n","category":"function"},{"location":"legacy/#TMI.surfacecontrol2field!","page":"Older functions","title":"TMI.surfacecontrol2field!","text":"function surfacecontrol2field!(c,u,γ)\nAdd surface control vector to existing 3D field\n\nArguments\n\nc:: state field, 3d tracer field with NaN on dry points, modified by function\nusfc:: surface control vector\nwet::BitArray mask of ocean points\n\n\n\n\n\nfunction surfacecontrol2field!(c,u,γ)\nAdd surface control vector to tracer vector\n\nArguments\n\nc:: state field, 3d tracer field with NaN on dry points, modified by function\nu:: surface control vector\nwet::BitArray mask of ocean points\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TMI","category":"page"},{"location":"#TMI","page":"Home","title":"TMI","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TMI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TMI]","category":"page"},{"location":"#TMI.Grid-Tuple{String}","page":"Home","title":"TMI.Grid","text":"function gridinit(TMIfile)\n\nConstruct the Grid given a file name\n\nArguments\n\nTMIfile::String: NetCDF file name for TMI version\n\nOutput\n\nγ::Grid: TMI grid struct\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{Any, BoundaryCondition{T}}} where T<:Real","page":"Home","title":"Base.:*","text":"`function *(C,d::BoundaryCondition)::BoundaryCondition`\nDefine scalar or matrix multiplication for BoundaryCondition`s\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{Any, Field{T}}} where T<:Real","page":"Home","title":"Base.:*","text":"`function *(C,d::Field)::Field`\nDefine scalar or matrix multiplication for fields\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{Field{T}, Field{T}}} where T<:Real","page":"Home","title":"Base.:*","text":"`function *(c::Field,d::Field)::Field`\nField by field multiplication is element-by-element.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Union{Tuple{T}, Tuple{BoundaryCondition{T}, BoundaryCondition{T}}} where T<:Real","page":"Home","title":"Base.:+","text":"`function +(c::BoundaryCondition,d::BoundaryCondition)::BoundaryCondition`\nDefine addition for Fields\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Union{Tuple{T}, Tuple{Field{T}, Field{T}}} where T<:Real","page":"Home","title":"Base.:+","text":"`function +(c::Field,d::Field)::Field`\nDefine addition for Fields\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{T}, Tuple{Field{T}, Field{T}}} where T<:Real","page":"Home","title":"Base.:-","text":"`function -(c::Field,d::Field)::Field`\nDefine addition for Fields\n\n\n\n\n\n","category":"method"},{"location":"#Base.:\\-Union{Tuple{T}, Tuple{Any, Field{T}}} where T<:Real","page":"Home","title":"Base.:\\","text":"`function \\(A,d::Field)::Field`\nDefine left division for Fields\nNeed two slashes to prevent invalid escape\n\n\n\n\n\n","category":"method"},{"location":"#Base.one-Tuple{Type{Field}}","page":"Home","title":"Base.one","text":"function oneunit, help for gridded Interpolations\n\n\n\n\n\n","category":"method"},{"location":"#Base.one-Union{Tuple{Field{T}}, Tuple{T}} where T<:Real","page":"Home","title":"Base.one","text":"function oneunit, help for gridded Interpolations\n\n\n\n\n\n","category":"method"},{"location":"#Base.ones","page":"Home","title":"Base.ones","text":"function ones(γ::Grid,name=:none,longname=\"unknown\",units=\"unknown\")::Field\n\n  initialize tracer field of ones on TMI grid\n  using a Field struct and constructor\n\nArguments\n\nγ::TMI.Grid\n\nOutput\n\nd::Field,  3d tracer field with NaN on dry points\n\n\n\n\n\n","category":"function"},{"location":"#Base.ones-Tuple{Int64, Int64, Grid}","page":"Home","title":"Base.ones","text":"function ones(dim::Int64,dimval::Int64,γ::Grid)::BoundaryCondition\n\n   Initialize boundary condition with ones\n\n\n\n\n\n","category":"method"},{"location":"#Base.vec-Union{Tuple{BoundaryCondition{T}}, Tuple{T}} where T<:Real","page":"Home","title":"Base.vec","text":"function vec(u)\n\nTurn a collection of controls into a vector\nfor use with Optim.jl. \nAn in-place version of this function would be handy.\n\n\n\n\n\n","category":"method"},{"location":"#Base.vec-Union{Tuple{NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N}}}}, Tuple{T}, Tuple{N}} where {N, T<:Real}","page":"Home","title":"Base.vec","text":"function vec(u)\n\nTurn a collection of controls into a vector\nfor use with Optim.jl. \nAn in-place version of this function would be handy.\n\n\n\n\n\n","category":"method"},{"location":"#Base.zeros","page":"Home","title":"Base.zeros","text":"function zeros(γ::Grid,name=:none,longname=\"unknown\",units=\"unknown\")::Field\n\n  initialize tracer field on TMI grid\n  using a Field struct and constructor\n\nArguments\n\nγ::TMI.Grid\n\nOutput\n\nd::Field,  3d tracer field with NaN on dry points\n\n\n\n\n\n","category":"function"},{"location":"#Base.zeros-2","page":"Home","title":"Base.zeros","text":"function zeros(wet,ltype=Float64)\ninitialize tracer field on TMI grid\nThis version will give an array\n\nArguments\n\nwet::BitArray mask of ocean points\nltype:: optional type argument, default=Float64\n\nOutput\n\nd:: 3d tracer field with NaN on dry points\n\n\n\n\n\n","category":"function"},{"location":"#Base.zeros-Tuple{Int64, Int64, Grid, Symbol, String, String}","page":"Home","title":"Base.zeros","text":"function zeros(dim::Int64,dimval::Int64,γ::Grid,name::Symbol,longname::String,units::String)::BoundaryCondition\n\n   Initialize boundary condition with zeroes\n\nArguments\n\ndim:\ndimval\nγ::Grid\nname::Symbol\nlongname::String\nunits::String\n\nOutput\n\nb::BoundaryCondition\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.dot-Union{Tuple{T}, Tuple{Field{T}, Field{T}}} where T<:Real","page":"Home","title":"LinearAlgebra.dot","text":"`function *(c::Field,d::Field)::Field`\nField by field multiplication is element-by-element.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.E","page":"Home","title":"TMI.E","text":"function E \nE anonymously calls field2obs\n\n\n\n\n\n","category":"function"},{"location":"#TMI.adjustboundarycondition!-Union{Tuple{T}, Tuple{BoundaryCondition{T}, BoundaryCondition{T}}} where T<:Real","page":"Home","title":"TMI.adjustboundarycondition!","text":"function adjustboundarycondition!(b::BoundaryCondition{T},u::BoundaryCondition{T}) where T <: Real\n\nadjust the (one) boundary condition \nproblem: passes back a mutated b\n\n\n\n\n\n","category":"method"},{"location":"#TMI.adjustboundarycondition!-Union{Tuple{T}, Tuple{N2}, Tuple{N1}, Tuple{NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N1}}}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N2}}}}} where {N1, N2, T<:Real}","page":"Home","title":"TMI.adjustboundarycondition!","text":"function adjustboundarycondition!(b::NamedTuple{<:Any, NTuple{N1,BoundaryCondition{T}}},u::NamedTuple{<:Any, NTuple{N2,BoundaryCondition{T}}}) where N1, N2, T <: Real\n\nadjust all boundary conditions b that are described in u\n\n\n\n\n\n","category":"method"},{"location":"#TMI.adjustboundarycondition-Union{Tuple{T}, Tuple{BoundaryCondition{T}, BoundaryCondition{T}}} where T<:Real","page":"Home","title":"TMI.adjustboundarycondition","text":"function adjustboundarycondition(b::BoundaryCondition{T},u::BoundaryCondition{T}) where T <: Real\n\nadjust the (one) boundary condition\n\n\n\n\n\n","category":"method"},{"location":"#TMI.adjustboundarycondition-Union{Tuple{T}, Tuple{N2}, Tuple{N1}, Tuple{NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N1}}}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N2}}}}} where {N1, N2, T<:Real}","page":"Home","title":"TMI.adjustboundarycondition","text":"function adjustboundarycondition(b::NamedTuple{<:Any, NTuple{N1,BoundaryCondition{T}}},u::NamedTuple{<:Any, NTuple{N2,BoundaryCondition{T}}}) where N1, N2, T <: Real\n\nadjust all boundary conditions b that are described in u\n\n\n\n\n\n","category":"method"},{"location":"#TMI.boundaryconditionatts-Tuple{Int64, Int64, Grid}","page":"Home","title":"TMI.boundaryconditionatts","text":"function boundaryconditionatts(dim::Int64,dimval::Int64,γ::Grid)\n\n   Help initialize boundary condition by getting some attributes\n\n\n\n\n\n","category":"method"},{"location":"#TMI.boundarymatrix-Tuple{Any, Any}","page":"Home","title":"TMI.boundarymatrix","text":"    function boundarymatrix(file,γ)\nRead and assemble the boundary matrix from MATLAB.\nTransfer to updated x,y,z version\n\nArguments\n\nfile: TMI MATLAB file name\nγ: TMI grid\n\nOutput\n\nB: boundary condition matrix\n\n\n\n\n\n","category":"method"},{"location":"#TMI.boundarymatrix2nc-Tuple{Any, Any}","page":"Home","title":"TMI.boundarymatrix2nc","text":"Save boundary matrix for transient model to NetCDF file\n\n\n\n\n\n","category":"method"},{"location":"#TMI.cartesianindex-Tuple{BitArray{3}}","page":"Home","title":"TMI.cartesianindex","text":"function cartesianindex(wet)\nRead and assemble the grid coordinates\naccording to a 3D tracer in x,y,z order\n\nArguments\n\nwet: BitArray logical mask for wet points\n\nOutput\n\nI: 3D Cartesian indices\n\n\n\n\n\n","category":"method"},{"location":"#TMI.cartesianindex-Tuple{String}","page":"Home","title":"TMI.cartesianindex","text":"function cartesianindex(file)\nRead and assemble the grid coordinates\naccording to the legacy MATLAB code (z,y,x order).\n\nArguments\n\nfile: TMI NetCDF file name\n\nOutput\n\nI: TMI Cartesian index for wet points\n\n\n\n\n\n","category":"method"},{"location":"#TMI.cellarea-Tuple{Any}","page":"Home","title":"TMI.cellarea","text":"Horizontal area of grid cell\n\n\n\n\n\n","category":"method"},{"location":"#TMI.cellvolume-Tuple{Any}","page":"Home","title":"TMI.cellvolume","text":"Volume of each grid cell.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.circulationmatrix-Tuple{Any, Any, Any}","page":"Home","title":"TMI.circulationmatrix","text":"function circulationmatrix(file,A,γ)\nRead and assemble the circulation matrix from the efficient storage of A and F₀ variables.\n\nArguments\n\nfile: TMI MATLAB file name\nA: TMI water-mass matrix\nγ: TMI grid\n\nOutput\n\nL: circulation matrix in xyz format\n\n\n\n\n\n","category":"method"},{"location":"#TMI.circulationmatrix-Tuple{Any, Any}","page":"Home","title":"TMI.circulationmatrix","text":"function circulationmatrix(file,γ)\nRead and assemble the circulation matrix from MATLAB.\nTransfer to updated x,y,z version\n\nArguments\n\nfile: TMI MATLAB file name\nγ: TMI grid\n\nOutput\n\nL: circulation matrix in xyz format\n\n\n\n\n\n","category":"method"},{"location":"#TMI.circulationmatrix2nc-Tuple{Any, Any, Any}","page":"Home","title":"TMI.circulationmatrix2nc","text":"Save circulation matrix L to NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.config2nc-NTuple{5, Any}","page":"Home","title":"TMI.config2nc","text":"Save TMI configuration to NetCDF format for non-proprietary access\n\n\n\n\n\n","category":"method"},{"location":"#TMI.config_from_mat-Tuple{Any}","page":"Home","title":"TMI.config_from_mat","text":"Configure TMI environment from original MATLAB output\n\n\n\n\n\n","category":"method"},{"location":"#TMI.config_from_nc-Tuple{Any}","page":"Home","title":"TMI.config_from_nc","text":"function config_from_nc(TMIversion)\nConfigure TMI environment from NetCDF input file.\n\nArguments\n\nTMIversion: TMI version for water-mass/circulation model\n\nOutput\n\nA: TMI steady-state water-mass matrix\nAlu: LU decomposition of A\nγ: TMI grid properties\nTMIfile: TMI file name\n\n\n\n\n\n","category":"method"},{"location":"#TMI.control2state-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T<:Real","page":"Home","title":"TMI.control2state","text":"function control2state(tracer2D,γ)\nturn 2D surface field into 3D field with zeroes below surface\n\nArguments\n\ntracer2D:: 2D surface tracer field\nwet::BitArray mask of ocean points\n\nOutput\n\ntracer3D:: 3d tracer field with NaN on dry points\n\n\n\n\n\n","category":"method"},{"location":"#TMI.costfunction_gridded_obs!-Union{Tuple{T}, Tuple{N2}, Tuple{N1}, Tuple{Any, Any, Vector{T}, Any, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N1}}}}, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N2}}}}, Field{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where {N1, N2, T<:Real}","page":"Home","title":"TMI.costfunction_gridded_obs!","text":"function costfunction_gridded_obs!(J,guvec,uvec::Vector{T},Alu,b₀::Union{BoundaryCondition{T},NamedTuple{<:Any, NTuple{N1,BoundaryCondition{T}}}},u₀::Union{BoundaryCondition{T},NamedTuple{<:Any, NTuple{N2,BoundaryCondition{T}}}},y::Field{T},Wⁱ::Diagonal{T, Vector{T}},γ::Grid) where {N1, N2, T <: Real}\n\n\n\n\n\n","category":"method"},{"location":"#TMI.costfunction_gridded_obs-Union{Tuple{T}, Tuple{N2}, Tuple{N1}, Tuple{Any, Any, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N1}}}}, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N2}}}}, Field{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where {N1, N2, T<:Real}","page":"Home","title":"TMI.costfunction_gridded_obs","text":"function costfunction_gridded_obs(uvec::Vector{T},Alu,b::BoundaryCondition{T},y::Field{T},Wⁱ::Diagonal{T, Vector{T}},γ::Grid) where T <: Real\n\nsquared model-data misfit for gridded data\ncontrols are a vector input for Optim.jl\n\nArguments\n\nJ: cost function of sum of squared misfits\ngJ: derivative of cost function wrt to controls\nu: controls, field format\nAlu: LU decomposition of water-mass matrix\nb: boundary conditions\ny: observations on grid\nWⁱ: inverse of W weighting matrix for observations\nγ: grid\n\n\n\n\n\n","category":"method"},{"location":"#TMI.costfunction_point_obs!-Union{Tuple{T}, Tuple{N2}, Tuple{N1}, Tuple{Any, Any, Vector{T}, Any, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N1}}}}, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N2}}}}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, Any, Grid}} where {N1, N2, T<:Real}","page":"Home","title":"TMI.costfunction_point_obs!","text":"function costfunction_point_obs!(J,guvec,uvec::Vector{T},Alu,b₀::BoundaryCondition{T},u₀::BoundaryCondition{T},y::Vector{T},Wⁱ::Diagonal{T, Vector{T}},wis,locs,Q⁻,γ::Grid) where T <: Real\n\nsquared model-data misfit for pointwise data\ncontrols are a vector input for Optim.jl\nIssue #1: couldn't figure out how to nest with costfunction_obs!\n\nArguments\n\nJ: cost function of sum of squared misfits\nguvec: derivative of cost function wrt to controls\nuvec: controls, vector format\nAlu: LU decomposition of water-mass matrix\nb: boundary condition\ny: pointwise observations\nWⁱ: inverse of W weighting matrix for observations\nwis: weights for interpolation (data sampling, E)\nlocs: data locations (lon,lat,depth)\nQ⁻: weights for control vector\nγ: grid\n\n\n\n\n\n","category":"method"},{"location":"#TMI.costfunction_point_obs-Union{Tuple{T}, Tuple{N2}, Tuple{N1}, Tuple{Vector{T}, Any, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N1}}}}, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N2}}}}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, Any, Grid}} where {N1, N2, T<:Real}","page":"Home","title":"TMI.costfunction_point_obs","text":"function costfunction_point_obs(uvec::Vector{T},Alu,b₀::BoundaryCondition{T},u₀::BoundaryCondition{T},y::Vector{T},Wⁱ::Diagonal{T, Vector{T}},wis,locs,Q⁻,γ::Grid) where T <: Real\n\nsquared model-data misfit for pointwise data\ncontrols are a vector input for Optim.jl\nIssue #1: couldn't figure out how to nest with costfunction_obs!\n\nArguments\n\nuvec: controls, vector format\nAlu: LU decomposition of water-mass matrix\nb: boundary condition\ny: pointwise observations\nWⁱ: inverse of W weighting matrix for observations\nwis: weights for interpolation (data sampling, E)\nlocs: data locations (lon,lat,depth)\nQ⁻: weights for control vector\nγ: grid\n\nOutput\n\nJ: cost function of sum of squared misfits\ngJ: derivative of cost function wrt to controls\n\n\n\n\n\n","category":"method"},{"location":"#TMI.depthindex-Tuple{Any}","page":"Home","title":"TMI.depthindex","text":"function depthindex(I) \nGet the k-index (depth level) from the Cartesian index\n\n\n\n\n\n","category":"method"},{"location":"#TMI.download_matfile-Tuple{String}","page":"Home","title":"TMI.download_matfile","text":"function download_matfile(TMIversion::String)\n\nDownload MATLAB file for given TMI version\n\nArguments\n\nTMIversion::String\n\nOutput\n\nTMIfile::String: TMI file name\n\nSide-effect\n\ndownload TMI input file if necessary\n\n\n\n\n\n","category":"method"},{"location":"#TMI.download_ncfile-Tuple{String}","page":"Home","title":"TMI.download_ncfile","text":"function download_ncfile(TMIversion::String)\n\nDownload NetCDF file for given TMI version\n\nArguments\n\nTMIversion::String\n\nOutput\n\nTMIfile::String: TMI file name\n\nSide-effect\n\ndownload TMI input file if necessary\n\n\n\n\n\n","category":"method"},{"location":"#TMI.eastindex-Tuple{Any}","page":"Home","title":"TMI.eastindex","text":"function eastindex(I) \nGet the vector index on the northern open boundary\n\n\n\n\n\n","category":"method"},{"location":"#TMI.fieldsatts-Tuple{}","page":"Home","title":"TMI.fieldsatts","text":"All variable names and attributes. Useful for writing NetCDF files.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.fld2vec-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{CartesianIndex{3}}}} where T<:Real","page":"Home","title":"TMI.fld2vec","text":"function fld2vec\nTransfer 3D field with accounting for ocean bathymetry to a vector without land points.\nThis is done more easily with a BitArray mask, i.e., vector = field[mask].\nThis function may be removed in the future.\n\nArguments\n\nfield: field in 3d form including land points (NaN)\nI: cartesian indices of ocean points\n\nOutput\n\nvector: field in vector form (no land points)\n\n\n\n\n\n","category":"method"},{"location":"#TMI.gadjustboundarycondition-Union{Tuple{T}, Tuple{BoundaryCondition{T}, BoundaryCondition{T}}} where T<:Real","page":"Home","title":"TMI.gadjustboundarycondition","text":"function gadjustboundarycondition!(b::BoundaryCondition{T},u::BoundaryCondition{T}) where T <: Real\n\nadjust the (one) boundary condition \nJust copy the variable.\nKeep this function so that calling functions can look alike.\nCould probably combine with lower function, use Union type\n\n\n\n\n\n","category":"method"},{"location":"#TMI.gadjustboundarycondition-Union{Tuple{T}, Tuple{N2}, Tuple{N1}, Tuple{NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N1}}}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N2}}}}} where {N1, N2, T<:Real}","page":"Home","title":"TMI.gadjustboundarycondition","text":"function gadjustboundarycondition!(b::BoundaryCondition{T},u::BoundaryCondition{T}) where T <: Real\n\nADJOINT CODE\nadjust the (one) boundary condition \nJust copy the variable.\nKeep this function so that calling functions can look alike.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.getboundarycondition-Tuple{Any, Any, Any, Grid}","page":"Home","title":"TMI.getboundarycondition","text":"Get boundary condition by extracting from 3D tracer\n\n\n\n\n\n","category":"method"},{"location":"#TMI.getboundarycondition-Tuple{Field, Any, Any}","page":"Home","title":"TMI.getboundarycondition","text":"function getboundarycondition(field::Field,dim,dimval)::BoundaryCondition\n\nGet boundary condition by extracting from Field (i.e., 3D tracer)\n\nArguments\n\nfield::Field: 3D tracer field with metadata and grid\ndim: dimension number (1,2,3) that the boundary plane has constant value\ndimval: index number in dimension dim that defines boundary plane\n\nOutput\n\nb::BoundaryCondition: boundary condition on a plane with metadata and grid\n\n\n\n\n\n","category":"method"},{"location":"#TMI.gobserve-Union{Tuple{T}, Tuple{Vector{T}, Field{T}, Any}} where T<:Real","page":"Home","title":"TMI.gobserve","text":"function gobserve(gy::Vector{T},c::Field{T},wis,γ) where T <: Real\n\nADJOINT Take a observation at location given by weights wis\nArguments not symmetric with `observe` due to splat operator\n\n\n\n\n\n","category":"method"},{"location":"#TMI.grid2nc-Tuple{Any, Any}","page":"Home","title":"TMI.grid2nc","text":"Put grid properties (Cartesian index) into NetCDF file\n\n\n\n\n\n","category":"method"},{"location":"#TMI.griddicts-Tuple{Any}","page":"Home","title":"TMI.griddicts","text":"Save grid dictionaries of attributes for writing to NetCDF file\n\n\n\n\n\n","category":"method"},{"location":"#TMI.gridprops-Tuple{Any}","page":"Home","title":"TMI.gridprops","text":"function gridprops(file)\nRead and assemble the grid properties.\n\nArguments\n\nfile: TMI NetCDF file name\n\nOutput\n\ngrid: TMI grid coordinates\n\n\n\n\n\n","category":"method"},{"location":"#TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T}, BoundaryCondition{T}}} where T<:Real","page":"Home","title":"TMI.gsetboundarycondition","text":"function gsetboundarycondition(gd::Field{T},b::BoundaryCondition{T}) where T<: Real\n\nADJOINT: apply boundary condition to the equation constraints\n\nArguments\n\nd::Field, equation constraints (i.e., right hand side)\nb::BoundaryCondition\n\n\n\n\n\n","category":"method"},{"location":"#TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{N}, Tuple{Field{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N}}}}} where {N, T<:Real}","page":"Home","title":"TMI.gsetboundarycondition","text":"function gsetboundarycondition(gd::Field{T},b::BoundaryCondition{T}) where T<: Real\n\nADJOINT: apply boundary condition to the equation constraints\n\nArguments\n\nd::Field, equation constraints (i.e., right hand side)\nb::BoundaryCondition\n\n\n\n\n\n","category":"method"},{"location":"#TMI.gsteadyinversion-Union{Tuple{T}, Tuple{Any, Any, BoundaryCondition{T}, Grid}} where T<:Real","page":"Home","title":"TMI.gsteadyinversion","text":"function gsteadyinversion(Alu,b;q=nothing,r=1.0)\n\nADJOINT invert for a steady-state tracer distribution\n\nArguments\n\nAlu: LU decomposition of water-mass matrix\nb: BoundaryCondition\nγ::Grid\n\nOptional Arguments\n\nq: interior sources/sinks of phosphate\nr: stochiometric ratio of tracer:phosphate\n\nOutput\n\nc::Field, steady-state tracer distribution\n\n\n\n\n\n","category":"method"},{"location":"#TMI.gsteadyinversion-Union{Tuple{T}, Tuple{N}, Tuple{Field{T}, Any, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N}}}, Grid}} where {N, T<:Real}","page":"Home","title":"TMI.gsteadyinversion","text":"function gsteadyinversion(gc::Field{T},Alu,b::NamedTuple{<:Any, NTuple{N,BoundaryCondition{T}}},γ::Grid;q=nothing,r=1.0)::Field{T} where {N, T <: Real}\n\nADDJOINT steady inversion for b::NamedTuple\n\n\n\n\n\n","category":"method"},{"location":"#TMI.horizontaldistance-Tuple{Any, Grid}","page":"Home","title":"TMI.horizontaldistance","text":"function horizontaldistance(loc,γ)\nreturn the Cartesian index and linear index \nof the nearest N neighbors\n\nArguments\n\nloc: 3-tuple of lon,lat,depth location\nγ: TMI.grid\n\nOutput\n\nhordist: horizontal distance to nearest tracer grid points\n\n\n\n\n\n","category":"method"},{"location":"#TMI.interpindex-Tuple{Any, Any}","page":"Home","title":"TMI.interpindex","text":"function interpindex(loc,γ)     Weights for linear interpolation.     The derivative of linear interpolation is needed in sensitivity studies.     ReverseDiff.jl could find this quantity automatically.     Instead we dig into the Interpolations.jl package to find the weights that are effectively the partial derivatives of the function.\n\nArguments\n\nc: a temporary tracer field, would be nice to make it unnecessary\nloc: (lon,lat,depth) tuple of a location of interest\nγ: TMI grid\n\nOutput\n\nδ: weights on a 3D tracer field grid\n\n\n\n\n\n","category":"method"},{"location":"#TMI.interpweights-Tuple{Any, Any}","page":"Home","title":"TMI.interpweights","text":"function interpweights(loc,γ)     Weights for linear interpolation.     The derivative of linear interpolation is needed in sensitivity studies.     ReverseDiff.jl could find this quantity automatically.     Instead we dig into the Interpolations.jl package to find the weights that are effectively the partial derivatives of the function.\n\nArguments\n\nloc: (lon,lat,depth) tuple of a location of interest\nγ: TMI grid\n\nOutput\n\nδ: weights on a 3D tracer field grid\n\n\n\n\n\n","category":"method"},{"location":"#TMI.latindex-Tuple{Any}","page":"Home","title":"TMI.latindex","text":"function latindex(I) \nGet the j-index (latitude index) from the Cartesian index\n\n\n\n\n\n","category":"method"},{"location":"#TMI.linearindex-Tuple{Any}","page":"Home","title":"TMI.linearindex","text":"function linearindex(wet)\nRead and assemble the grid coordinates.\n\nArguments\n\nwet: 3D mask for wet points\n\nOutput\n\nR: array of linear indices, but not a LinearIndices type\n\n\n\n\n\n","category":"method"},{"location":"#TMI.lonindex-Tuple{Any}","page":"Home","title":"TMI.lonindex","text":"function lonindex(I) \nGet the i-index (lon index) from the Cartesian index\n\n\n\n\n\n","category":"method"},{"location":"#TMI.matfields2nc-Tuple{Any, Any}","page":"Home","title":"TMI.matfields2nc","text":"Read 3D fields from mat file and save to NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.matrix_zyx2xyz-Tuple{Any, Any, Any}","page":"Home","title":"TMI.matrix_zyx2xyz","text":"    function matrix_zyx2xyz(TMIfile,Azyx,γ)\n\nTransfer zyx format water-mass matrix A to xyz format\n\nArguments\n\nAzyx: water-mass matrix in zyx format\nγ: TMI grid\n\nOutput\n\nAxyz: water-mass matrix in xyz format\n\n\n\n\n\n","category":"method"},{"location":"#TMI.maturl-Tuple{Any}","page":"Home","title":"TMI.maturl","text":"function maturl(TMIversion)\nFind *mat file here.\nplaceholder function to give location (URL) of Google Drive input\nin the future, consider a struct or Dict that describes all TMI versions.\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\n\nOutput\n\nurl: location (URL) for download\n\n\n\n\n\n","category":"method"},{"location":"#TMI.meanage-Tuple{Any, Any, Any}","page":"Home","title":"TMI.meanage","text":"function meanage(TMIversion,Alu,γ)\nMean or ideal age\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\nAlu: LU decomposition of water-mass matrix A\nγ: TMI grid\n\nOutput\n\na: mean age [yr]\n\n\n\n\n\n","category":"method"},{"location":"#TMI.ncurl-Tuple{Any}","page":"Home","title":"TMI.ncurl","text":"function ncurl(TMIversion)\nplaceholder function to give location (URL) of NetCDF Google Drive input\nin the future, consider a struct or Dict that describes all TMI versions.\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\n\nOutput\n\nurl: location (URL) for download\n\n\n\n\n\n","category":"method"},{"location":"#TMI.nearestneighbor","page":"Home","title":"TMI.nearestneighbor","text":"function nearestneighbor(loc,γ)\nreturn the Cartesian index and linear index \nof the nearest N neighbors\n\nArguments\n\nloc: 3-tuple of lon,lat,depth location\nγ: TMI.grid\n\nOutput\n\nInn: Cartesian indices of nearest neighbor\n\n#- Rnn: linear indices of nearest neighbor, Removed from code\n\n\n\n\n\n","category":"function"},{"location":"#TMI.nearestneighbormask","page":"Home","title":"TMI.nearestneighbormask","text":"function nearestneighbormask\nMake a 3D tracer field that is 1 at location \nof nearest neighbor, 0 elsewhere\n\nArguments\n\nloc: location in a 3-tuple (lon,lat,depth)\nγ: TMI.grid\n\nOutput\n\nδ: nearest neighbor mask 3D field\n\n\n\n\n\n","category":"function"},{"location":"#TMI.northindex-Tuple{Any}","page":"Home","title":"TMI.northindex","text":"function northindex(I) \nGet the vector index on the northern open boundary\n\n\n\n\n\n","category":"method"},{"location":"#TMI.observe-Union{Tuple{T}, Tuple{Field{T}, Array{Tuple{Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}}, 1}, Grid}} where T<:Real","page":"Home","title":"TMI.observe","text":"function observe\nTake a observation at location given by weights wis\n\n\n\n\n\n","category":"method"},{"location":"#TMI.optim2nc-Tuple{Any}","page":"Home","title":"TMI.optim2nc","text":"Save optimization parameters to NetCDF file)\n\nFuture considerations: split into 2 functions\n\nread from mat\nsave to nc\n\n\n\n\n\n","category":"method"},{"location":"#TMI.oxygen-Tuple{Any, Any}","page":"Home","title":"TMI.oxygen","text":"Reconstruct dissolved oxygen (that doesn't exist in TMI product) by assuming same oxygen saturation fraction as modern\n\n\n\n\n\n","category":"method"},{"location":"#TMI.readfield-Tuple{Any, Any, Grid}","page":"Home","title":"TMI.readfield","text":"function readfield(file,tracername,γ)\nRead a tracer field from NetCDF but return it \nas a Field.\n\nUse NCDatasets so that Unicode is correct\n\nArguments\n\nfile: TMI NetCDF file name\ntracername: name of tracer\nγ::Grid, TMI grid specification\n\nOutput\n\nc::Field\n\n\n\n\n\n","category":"method"},{"location":"#TMI.readtracer-Tuple{Any, Any}","page":"Home","title":"TMI.readtracer","text":"function readtracer(file,tracername)\nRead a tracer field from NetCDF.\n\nArguments\n\nfile: TMI NetCDF file name\ntracername: name of tracer\n\nOutput\n\nc: 3D tracer field\n\n\n\n\n\n","category":"method"},{"location":"#TMI.regeneratedphosphate-Tuple{Any, Any, Any}","page":"Home","title":"TMI.regeneratedphosphate","text":"function regeneratedphosphate(TMIversion,Alu,γ)\nRegenerated (i.e., accumulated, remineralized) phosphate\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\nAlu: LU decomposition of water-mass matrix A\nγ: TMI grid\n\nOutput\n\nPO₄ᴿ: regenerated phosphate\n\n\n\n\n\n","category":"method"},{"location":"#TMI.regions2nc-Tuple{Any, Any}","page":"Home","title":"TMI.regions2nc","text":"Read vectors from mat file, translate to 3D,  and save surface field to NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.section-Union{Tuple{T}, Tuple{Field{T}, Any}} where T<:Real","page":"Home","title":"TMI.section","text":"function section\nView latitude-depth slice of field\n\nArguments\n\nc::Field, 3D tracer field plus meta data\nlon: longitude of section\n\nOutput\n\ncsection: 2d slice of field\n\n\n\n\n\n","category":"method"},{"location":"#TMI.setboundarycondition!-Union{Tuple{T}, Tuple{Field{T}, BoundaryCondition{T}}} where T<:Real","page":"Home","title":"TMI.setboundarycondition!","text":"function setboundarycondition!(d::Field,b::BoundaryCondition)\napply boundary condition to the equation constraints\n\nArguments\n\nd::Field, equation constraints (i.e., right hand side)\nb::BoundaryCondition\n\n\n\n\n\n","category":"method"},{"location":"#TMI.setboundarycondition!-Union{Tuple{T}, Tuple{N}, Tuple{Field{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N}}}}} where {N, T<:Real}","page":"Home","title":"TMI.setboundarycondition!","text":"function setboundarycondition!(d::Field{T},b::NamedTuple{<:Any, NTuple{N,BoundaryCondition{T}}}) where {N, T <: Real}\n\nset all boundary conditions in a Named Tuple\n\n\n\n\n\n","category":"method"},{"location":"#TMI.setsource!-Union{Tuple{T}, Tuple{Field{T}, Field{T}}, Tuple{Field{T}, Field{T}, Any}} where T<:Real","page":"Home","title":"TMI.setsource!","text":"function setsource!(d::Field,q::Field,r::Number)\napply interior source q to the equation constraints d\n\nArguments\n\nd::Field, equation constraints (i.e., right hand side)\nq::Field, interior source\nr::Number, default = 1.0, stoichiometric ratio\n\n\n\n\n\n","category":"method"},{"location":"#TMI.shiftloc-Tuple{Any, Any}","page":"Home","title":"TMI.shiftloc","text":"function  shiftloc(loc)\n\nsometimes loc longitudes are outside of grid due to different conventions\nassumption: 360° shift is enough to get back on grid\n\n\n\n\n\n","category":"method"},{"location":"#TMI.southindex-Tuple{Any}","page":"Home","title":"TMI.southindex","text":"function southindex(I) \nGet the vector-index on the southern open boundary\n\n\n\n\n\n","category":"method"},{"location":"#TMI.sparsedatamap-Union{Tuple{T}, Tuple{N2}, Tuple{N1}, Tuple{Vector{T}, Any, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N1}}}}, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N2}}}}, Vector{T}, Any, Array{Tuple{Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}}, 1}, Any, Any, Grid}, Tuple{Vector{T}, Any, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N1}}}}, Union{BoundaryCondition{T}, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N2}}}}, Vector{T}, Any, Array{Tuple{Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}}, 1}, Any, Any, Grid, Any}} where {N1, N2, T<:Real}","page":"Home","title":"TMI.sparsedatamap","text":"function sparsedatamap(u₀::Vector{T},Alu,b::BoundaryCondition{T},u::BoundaryCondition{T},y::Vector{T},W⁻,wis,locs,Q⁻,γ::Grid;iterations=10) where T <: Real\n\n Find the distribution of a tracer given:\n (a) the pathways described by A or its LU decomposition Alu,\n (b) first-guess boundary conditions and interior sources given by d₀,\n (c) perturbations to the surface boundary condition u₀\nthat best fits observations, y,\naccording to the cost function,\nJ = (ỹ - y)ᵀ W⁻¹ (ỹ - y)\nsubject to Aỹ = d₀ + Γ u₀.                 \nW⁻ is a (sparse) weighting matrix.\nSee Supplementary Section 2, Gebbie & Huybers 2011.\n\nArguments\n\nu₀:\nAlu:\nb: first guess of boundary conditions and interior sources\ny: observations on 3D grid\nW⁻: weighting matrix best chosen as inverse error covariance matrix\nfg!: compute cost function and gradient in place\nγ: grid\n\n\n\n\n\n","category":"method"},{"location":"#TMI.steadyclimatology-Tuple{Any, Any, Any}","page":"Home","title":"TMI.steadyclimatology","text":"function steadyclimatology(u₀,fg!,iterations)      Find the distribution of a tracer given:      (a) the pathways described by A or its LU decomposition Alu,      (b) first-guess boundary conditions and interior sources given by d₀,      (c) perturbations to the surface boundary condition u₀     that best fits observations, y,     according to the cost function,     J = (ỹ - y)ᵀ W⁻¹ (ỹ - y)     subject to Aỹ = d₀ + Γ u₀.                      W⁻ is a (sparse) weighting matrix.     See Supplementary Section 2, Gebbie & Huybers 2011.\n\nArguments\n\nu₀:\nfg!: compute cost function and gradient in place\niterations: number of optimization iterations\n\n\n\n\n\n","category":"method"},{"location":"#TMI.steadyinversion-Union{Tuple{T}, Tuple{Any, BoundaryCondition{T}, Grid}} where T<:Real","page":"Home","title":"TMI.steadyinversion","text":"function steadyinversion(Alu,b;q=nothing,r=1.0)\ninvert for a steady-state tracer distribution\n\nArguments\n\nAlu: LU decomposition of water-mass matrix\nb: boundary condition\nγ::Grid\n\nOptional Arguments\n\nq: interior sources/sinks of phosphate\nr: stochiometric ratio of tracer:phosphate\n\nOutput\n\nc::Field, steady-state tracer distribution\n\n\n\n\n\n","category":"method"},{"location":"#TMI.steadyinversion-Union{Tuple{T}, Tuple{N}, Tuple{Any, NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N}}}, Grid}} where {N, T<:Real}","page":"Home","title":"TMI.steadyinversion","text":"function steadyinversion(Alu,b::NamedTuple{<:Any, NTuple{N,BoundaryCondition{T}}},γ::Grid;q=nothing,r=1.0)::Field{T} where {N, T <: Real}\n\nsteady inversion for b::NamedTuple\n\n\n\n\n\n","category":"method"},{"location":"#TMI.surface_oxygensaturation-Tuple{Any}","page":"Home","title":"TMI.surface_oxygensaturation","text":"Surface oxygen saturation value and fraction of saturation value in field \n\n\n\n\n\n","category":"method"},{"location":"#TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{T}, Any}} where T<:Real","page":"Home","title":"TMI.surfacecontrol2field!","text":"function surfacecontrol2field!(c,u,γ)\nAdd surface control vector to existing 3D field\n\nArguments\n\nc:: state field, 3d tracer field with NaN on dry points, modified by function\nusfc:: surface control vector\nwet::BitArray mask of ocean points\n\n\n\n\n\n","category":"method"},{"location":"#TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Any}} where T<:Real","page":"Home","title":"TMI.surfacecontrol2field!","text":"function surfacecontrol2field!(c,u,γ)\nAdd surface control vector to tracer vector\n\nArguments\n\nc:: state field, 3d tracer field with NaN on dry points, modified by function\nu:: surface control vector\nwet::BitArray mask of ocean points\n\n\n\n\n\n","category":"method"},{"location":"#TMI.surfacecontrol2field-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T<:Real","page":"Home","title":"TMI.surfacecontrol2field","text":"function surfacecontrol2field(usfc,γ.wet)\nturn surface control vector into 3D field with zeroes below surface\n\nArguments\n\nusfc:: surface control vector\nwet::BitArray mask of ocean points\n\nOutput\n\ntracer3D:: 3d tracer field with NaN on dry points\n\n\n\n\n\n","category":"method"},{"location":"#TMI.surfaceindex-Tuple{Any}","page":"Home","title":"TMI.surfaceindex","text":"function surfaceindex(I) \nGet the vector-index where depth level == 1 and it is ocean.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.surfaceorigin-Tuple{Any, Any, Grid}","page":"Home","title":"TMI.surfaceorigin","text":"function surfaceorigin(TMIversion,loc)\n Find the surface origin of water for some interior box \n This is equivalent to solving a sensitivity problem:\n The mass fraction at a location `loc` of interest is \n`c[loc] = δᵀ c`, where `δ` samples the location of the global mass-fraction variable, c.\nThen the sensitivity of `c[loc]` is: d(c[loc])/d(d) = A⁻ᵀ δ.\nThe derivative is solved using the constraint: Ac = d.\nThe sensitivity is exactly the mass fraction originating from each source.      \nThis problem is mathematically similar to determining how the ocean is filled.\n\nArguments\n\nloc: location (lon,lat,depth) of location of interest\nAlu: LU decomposition of water-mass matrix A\nγ: TMI grid\n\nOutput\n\norigin: surface map of fraction of source water for a given location, log10 of effective depth, in terms of a BoundaryCondition\n\n\n\n\n\n","category":"method"},{"location":"#TMI.surfacepatch-Tuple{Any, Any, Grid}","page":"Home","title":"TMI.surfacepatch","text":"function surfacepatch\nMake a surface boundary condition\nwith a rectangular patch\n\nArguments\n\nlonbox: longitudes of box edges\nlatbox: latitudes of box edges\nγ: TMI.grid\n\nOutput\n\nd: vector that describes surface patch\n\n\n\n\n\n","category":"method"},{"location":"#TMI.surfaceregion-Tuple{String, String, Grid}","page":"Home","title":"TMI.surfaceregion","text":" function surfaceregion(TMIversion::String,region::String,γ::Grid)::BoundaryCondition\n\nRead an oceanographically-relevant surface region from NetCDF file. (Also could be read from mat file.)\nReturn a BoundaryCondition\n\n\n\n\n\n","category":"method"},{"location":"#TMI.synthetic_observations","page":"Home","title":"TMI.synthetic_observations","text":"function synthetic_observations(TMIversion,variable,locs)\nSynthetic observations that are a contaminated version of real observations\nThis version: observations with random (uniform) spatial sampling\n\nArguments\n\nTMIversion::String: version of TMI water-mass/circulation model\nvariable::String: variable name to use as template\nN: number of observations\n\nOutput\n\ny: contaminated observations on 3D grid\nW⁻: appropriate weighting (inverse covariance) matrix for these observations,\nytrue: uncontaminated observations, 3D field\nlocs: 3-tuples of locations for observations\nwis: weighted indices for interpolation to locs sites\n\n\n\n\n\n","category":"function"},{"location":"#TMI.synthetic_observations-Tuple{Any, Any, Any}","page":"Home","title":"TMI.synthetic_observations","text":"function synthetic_observations(TMIversion,variable)\nSynthetic observations that are a contaminated version of real observations\nThis version: gridded observations\n\nArguments\n\nTMIversion::String: version of TMI water-mass/circulation model\nvariable::String: variable name to use as template\n\nOutput\n\ny: contaminated observations on 3D grid\nW⁻: appropriate weighting (inverse covariance) matrix for these observations,\nθtrue: real observations, 3D field\n\n\n\n\n\n","category":"method"},{"location":"#TMI.tracerinit-Tuple{Any, Any, Any}","page":"Home","title":"TMI.tracerinit","text":"function tracerinit(wet,vec,I)\n      initialize tracer field on TMI grid\n    perhaps better to have a tracer struct and constructor\n\nArguments\n\nwet:: BitArray mask of ocean points\nvec:: vector of values at wet points\nI:: Cartesian Index for vector\n\nOutput\n\nfield:: 3d tracer field with NaN on dry points\n\n\n\n\n\n","category":"method"},{"location":"#TMI.trackpathways-NTuple{4, Any}","page":"Home","title":"TMI.trackpathways","text":"function trackpathways(TMIversion,latbox,lonbox)\nTrack the pathways of a user-defined water mass.\n Steps: (a) define the water mass by a rectangular surface patch dyed with passive tracer concentration of         (b) propagate the dye with the matrix A, with the result being the fraction of water originating from the surface region.\n See Section 2b of Gebbie & Huybers 2010, esp. eqs. (15)-(17).\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\nlatbox: min and max latitude of box\nlonbox: min and max longitude of box\nγ: TMI grid\n\nOutput\n\nc: fraction of water from surface source\n\n\n\n\n\n","category":"method"},{"location":"#TMI.unvec!-Union{Tuple{T}, Tuple{BoundaryCondition{T}, Vector{T}}} where T<:Real","page":"Home","title":"TMI.unvec!","text":"function unvec!(u,uvec)\n\nUndo the operations by vec(u)\nNeeds to update u because attributes of \nu need to be known at runtime.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.unvec!-Union{Tuple{T}, Tuple{N}, Tuple{NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N}}}, Vector{T}}} where {N, T<:Real}","page":"Home","title":"TMI.unvec!","text":"function unvec!(u,uvec)\n\nUndo the operations by vec(u)\nNeeds to update u because attributes of \nu need to be known at runtime.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.unvec-Union{Tuple{T}, Tuple{BoundaryCondition{T}, Vector{T}}} where T<:Real","page":"Home","title":"TMI.unvec","text":"function unvec(u,uvec)\n\nReplace u with new u\nUndo the operations by vec(u)\nNeeds to update u because attributes of \nu need to be known at runtime.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.unvec-Union{Tuple{T}, Tuple{N}, Tuple{NamedTuple{<:Any, Tuple{Vararg{BoundaryCondition{T}, N}}}, Vector{T}}} where {N, T<:Real}","page":"Home","title":"TMI.unvec","text":"function unvec(utemplate,uvec)\n\nUndo the operations by vec(u)\nNeeds to update u because attributes of \nu need to be known at runtime.\n\n\n\n\n\n","category":"method"},{"location":"#TMI.updatelinearindex-Tuple{Any, Any, Any}","page":"Home","title":"TMI.updatelinearindex","text":"function updatelinearindex(izyx,Izyx,R)\nLinear index translated from z,y,x to x,y,z accounting\n\nArguments\n\nizyx: index of interest in z,y,x accounting\nIzyx: wet Cartesian Index for z,y,x\nR: Linear indices for x,y,z \n\nOutput\n\nixyz: index of interest in x,y,z accounting\n\n\n\n\n\n","category":"method"},{"location":"#TMI.vec2fld-Union{Tuple{T}, Tuple{Vector{T}, Vector{CartesianIndex{3}}}} where T<:Real","page":"Home","title":"TMI.vec2fld","text":"function vec2fld\nTransfer a vector to a 3D field with accounting for ocean bathymetry\n\nArguments\n\nvector: field in vector form (no land points)\nI: cartesian indices of ocean points\n\nOutput\n\nfield: field in 3d form including land points (NaN)\n\n\n\n\n\n","category":"method"},{"location":"#TMI.volumefilled-Tuple{Any, Any, Any}","page":"Home","title":"TMI.volumefilled","text":"function volumefilled(TMIversion)\nFind the ocean volume that has originated from each surface box.\n This is equivalent to solving a sensitivity problem:\n The total volume is V = vᵀ c , where v is the volume of each box \n and c is the fraction of volume from a given source which\n satisfies the equation A c = d.                     \n Next, dV/d(d) = A⁻ᵀ v, and dV/d(d) is exactly the volume originating from each source.\n\n See Section 3 and Supplementary Section 4, Gebbie & Huybers 2011.\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\nAlu: LU decomposition of water-mass matrix A\nγ: TMI.grid\n\nOutput\n\nvolume: log10 of global ocean volume filled by a surface region, exists at surface, therefore given BoundaryCondition type\n\n\n\n\n\n","category":"method"},{"location":"#TMI.watermassdistribution-NTuple{4, Any}","page":"Home","title":"TMI.watermassdistribution","text":"function watermassdistribution(TMIversion,latbox,lonbox)\nTrack the pathways of a user-defined water mass.\n Steps: (a) define the water mass by an oceanographically-relevant surface patch dyed with passive tracer concentration of one\n     (b) propagate the dye with the matrix A, with the result being the fraction of water originating from the surface region.\n See Section 2b of Gebbie & Huybers 2010, esp. eqs. (15)-(17).\n\nArguments\n\nTMIversion: version of TMI water-mass/circulation model\nAlu: LU decomposition of water-mass matrix A\nregion: name of pre-defined surface region\nγ: TMI grid\n\nOutput\n\ng: water-mass fraction\n\n\n\n\n\n","category":"method"},{"location":"#TMI.watermassmatrix-Tuple{Any}","page":"Home","title":"TMI.watermassmatrix","text":"function watermassmatrix(file)\nRead and assemble the water-mass matrix.\n\nArguments\n\nfile: TMI NetCDF or MATLAB file name\n\nOutput\n\nA: water-mass matrix\n\n\n\n\n\n","category":"method"},{"location":"#TMI.westindex-Tuple{Any}","page":"Home","title":"TMI.westindex","text":"function westindex(I) \nGet the vector index on the western open boundary\n\n\n\n\n\n","category":"method"},{"location":"#TMI.wetlocation-Tuple{Any}","page":"Home","title":"TMI.wetlocation","text":"function wetlocation(γ)\nGet (lon,lat,depth) tuples of wet locations.\nAllow a location to be wet if at least one out of 8 nearby gridpoints is wet.\nCertainly \"wet\" gridpoints could be defined more strictly.\n\nArguments\n\nγ: TMI.grid\n\nOutput\n\nloc: lon,lat,depth \n\n\n\n\n\n","category":"method"},{"location":"#TMI.writefield-Union{Tuple{T}, Tuple{Any, Field{T}}} where T<:Real","page":"Home","title":"TMI.writefield","text":"function writefield(file,field)\n\nWrite a Field to NetCDF.\n\nUse NCDatasets so that Unicode is correct\n\nArguments\n\nfile: TMI NetCDF file name\nfield::Field: a TMI.Field struct\n\nOutput\n\nnone\n\nSide-effect\n\nwrite to file\n\n\n\n\n\n","category":"method"},{"location":"#TMI.Γsfc","page":"Home","title":"TMI.Γsfc","text":"function Γsfc \nΓsfc anonymously calls surfacecontrol2field\n\n\n\n\n\n","category":"function"},{"location":"#TMI.Γsfc!","page":"Home","title":"TMI.Γsfc!","text":"function Γsfc! \nΓsfc! anonymously calls surfacecontrol2field!\n\n\n\n\n\n","category":"function"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"CurrentModule = TMI","category":"page"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Useful utilities for TMI.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"TMI.cellarea\nTMI.cellvolume\nTMI.layerthickness\nTMI.zonalgriddist\nTMI.surfacepatch\nTMI.nearestneighbormask\nTMI.nearestneighbor\nTMI.horizontaldistance\nTMI.zeros\nTMI.ones\nTMI.tracerinit\nTMI.maximum\nTMI.minimum\nTMI.\\\nTMI.+\nTMI.*\nTMI.dot\nTMI.setsource\nTMI.vec\nTMI.unvec!\nTMI.unvec\nTMI.surface_oxygensaturation\nTMI.oxygen\nTMI.synthetic_observations\nTMI.observe\nTMI.gobserve\nTMI.location_obs\nTMI.costfunction_gridded_obs\nTMI.costfunction_gridded_obs!\nTMI.costfunction_point_obs\nTMI.costfunction_point_obs!\nTMI.steadyinversion\nTMI.gsteadyinversion\nTMI.wetlocation\nTMI.iswet","category":"page"},{"location":"utils/#TMI.nearestneighbormask","page":"Utilities","title":"TMI.nearestneighbormask","text":"function nearestneighbormask\nMake a 3D tracer field that is 1 at location \nof nearest neighbor, 0 elsewhere\n\nArguments\n\nloc: location in a 3-tuple (lon,lat,depth)\nγ: TMI.grid\n\nOutput\n\nδ: nearest neighbor mask 3D field\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.nearestneighbor","page":"Utilities","title":"TMI.nearestneighbor","text":"function nearestneighbor(loc,γ)\nreturn the Cartesian index and linear index \nof the nearest N neighbors\n\nArguments\n\nloc: 3-tuple of lon,lat,depth location\nγ: TMI.grid\n\nOutput\n\nInn: Cartesian indices of nearest neighbor\n\n#- Rnn: linear indices of nearest neighbor, Removed from code\n\n\n\n\n\n","category":"function"},{"location":"utils/#Base.zeros","page":"Utilities","title":"Base.zeros","text":"function zeros(γ::Grid,name=:none,longname=\"unknown\",units=\"unknown\")::Field\n\n  initialize tracer field on TMI grid\n  using a Field struct and constructor\n\nArguments\n\nγ::TMI.Grid\n\nOutput\n\nd::Field,  3d tracer field with NaN on dry points\n\n\n\n\n\nfunction zeros(wet,ltype=Float64)\ninitialize tracer field on TMI grid\nThis version will give an array\n\nArguments\n\nwet::BitArray mask of ocean points\nltype:: optional type argument, default=Float64\n\nOutput\n\nd:: 3d tracer field with NaN on dry points\n\n\n\n\n\nfunction zeros(dim::Int64,dimval::Int64,γ::Grid,name::Symbol,longname::String,units::String)::BoundaryCondition\n\n   Initialize boundary condition with zeroes\n\nArguments\n\ndim:\ndimval\nγ::Grid\nname::Symbol\nlongname::String\nunits::String\n\nOutput\n\nb::BoundaryCondition\n\n\n\n\n\n","category":"function"},{"location":"utils/#Base.ones","page":"Utilities","title":"Base.ones","text":"function ones(γ::Grid,name=:none,longname=\"unknown\",units=\"unknown\")::Field\n\n  initialize tracer field of ones on TMI grid\n  using a Field struct and constructor\n\nArguments\n\nγ::TMI.Grid\n\nOutput\n\nd::Field,  3d tracer field with NaN on dry points\n\n\n\n\n\nfunction ones(dim::Int64,dimval::Int64,γ::Grid)::BoundaryCondition\n\n   Initialize boundary condition with ones\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.tracerinit","page":"Utilities","title":"TMI.tracerinit","text":"function tracerinit(wet,vec,I)\n      initialize tracer field on TMI grid\n    perhaps better to have a tracer struct and constructor\n\nArguments\n\nwet:: BitArray mask of ocean points\nvec:: vector of values at wet points\nI:: Cartesian Index for vector\n\nOutput\n\nfield:: 3d tracer field with NaN on dry points\n\n\n\n\n\n","category":"function"},{"location":"utils/#Base.vec","page":"Utilities","title":"Base.vec","text":"function vec(u)\n\nTurn a collection of controls into a vector\nfor use with Optim.jl. \nAn in-place version of this function would be handy.\n\n\n\n\n\nfunction vec(u)\n\nTurn a collection of controls into a vector\nfor use with Optim.jl. \nAn in-place version of this function would be handy.\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.unvec!","page":"Utilities","title":"TMI.unvec!","text":"function unvec!(u,uvec)\n\nUndo the operations by vec(u)\nNeeds to update u because attributes of \nu need to be known at runtime.\n\n\n\n\n\nfunction unvec!(u,uvec)\n\nUndo the operations by vec(u)\nNeeds to update u because attributes of \nu need to be known at runtime.\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.unvec","page":"Utilities","title":"TMI.unvec","text":"function unvec(utemplate,uvec)\n\nUndo the operations by vec(u)\nNeeds to update u because attributes of \nu need to be known at runtime.\n\n\n\n\n\nfunction unvec(u,uvec)\n\nReplace u with new u\nUndo the operations by vec(u)\nNeeds to update u because attributes of \nu need to be known at runtime.\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.surface_oxygensaturation","page":"Utilities","title":"TMI.surface_oxygensaturation","text":"Surface oxygen saturation value and fraction of saturation value in field \n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.oxygen","page":"Utilities","title":"TMI.oxygen","text":"Reconstruct dissolved oxygen (that doesn't exist in TMI product) by assuming same oxygen saturation fraction as modern\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.synthetic_observations","page":"Utilities","title":"TMI.synthetic_observations","text":"function synthetic_observations(TMIversion,variable)\nSynthetic observations that are a contaminated version of real observations\nThis version: gridded observations\n\nArguments\n\nTMIversion::String: version of TMI water-mass/circulation model\nvariable::String: variable name to use as template\n\nOutput\n\ny: contaminated observations on 3D grid\nW⁻: appropriate weighting (inverse covariance) matrix for these observations,\nθtrue: real observations, 3D field\n\n\n\n\n\nfunction synthetic_observations(TMIversion,variable,locs)\nSynthetic observations that are a contaminated version of real observations\nThis version: observations with random (uniform) spatial sampling\n\nArguments\n\nTMIversion::String: version of TMI water-mass/circulation model\nvariable::String: variable name to use as template\nN: number of observations\n\nOutput\n\ny: contaminated observations on 3D grid\nW⁻: appropriate weighting (inverse covariance) matrix for these observations,\nytrue: uncontaminated observations, 3D field\nlocs: 3-tuples of locations for observations\nwis: weighted indices for interpolation to locs sites\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.observe","page":"Utilities","title":"TMI.observe","text":"function observe\nTake a observation at location given by weights wis\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.gobserve","page":"Utilities","title":"TMI.gobserve","text":"function gobserve(gy::Vector{T},c::Field{T},wis,γ) where T <: Real\n\nADJOINT Take a observation at location given by weights wis\nArguments not symmetric with `observe` due to splat operator\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.costfunction_gridded_obs","page":"Utilities","title":"TMI.costfunction_gridded_obs","text":"function costfunction_gridded_obs(uvec::Vector{T},Alu,b::BoundaryCondition{T},y::Field{T},Wⁱ::Diagonal{T, Vector{T}},γ::Grid) where T <: Real\n\nsquared model-data misfit for gridded data\ncontrols are a vector input for Optim.jl\n\nArguments\n\nJ: cost function of sum of squared misfits\ngJ: derivative of cost function wrt to controls\nu: controls, field format\nAlu: LU decomposition of water-mass matrix\nb: boundary conditions\ny: observations on grid\nWⁱ: inverse of W weighting matrix for observations\nγ: grid\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.costfunction_gridded_obs!","page":"Utilities","title":"TMI.costfunction_gridded_obs!","text":"function costfunction_gridded_obs!(J,guvec,uvec::Vector{T},Alu,b₀::Union{BoundaryCondition{T},NamedTuple{<:Any, NTuple{N1,BoundaryCondition{T}}}},u₀::Union{BoundaryCondition{T},NamedTuple{<:Any, NTuple{N2,BoundaryCondition{T}}}},y::Field{T},Wⁱ::Diagonal{T, Vector{T}},γ::Grid) where {N1, N2, T <: Real}\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.costfunction_point_obs","page":"Utilities","title":"TMI.costfunction_point_obs","text":"function costfunction_point_obs(uvec::Vector{T},Alu,b₀::BoundaryCondition{T},u₀::BoundaryCondition{T},y::Vector{T},Wⁱ::Diagonal{T, Vector{T}},wis,locs,Q⁻,γ::Grid) where T <: Real\n\nsquared model-data misfit for pointwise data\ncontrols are a vector input for Optim.jl\nIssue #1: couldn't figure out how to nest with costfunction_obs!\n\nArguments\n\nuvec: controls, vector format\nAlu: LU decomposition of water-mass matrix\nb: boundary condition\ny: pointwise observations\nWⁱ: inverse of W weighting matrix for observations\nwis: weights for interpolation (data sampling, E)\nlocs: data locations (lon,lat,depth)\nQ⁻: weights for control vector\nγ: grid\n\nOutput\n\nJ: cost function of sum of squared misfits\ngJ: derivative of cost function wrt to controls\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.costfunction_point_obs!","page":"Utilities","title":"TMI.costfunction_point_obs!","text":"function costfunction_point_obs!(J,guvec,uvec::Vector{T},Alu,b₀::BoundaryCondition{T},u₀::BoundaryCondition{T},y::Vector{T},Wⁱ::Diagonal{T, Vector{T}},wis,locs,Q⁻,γ::Grid) where T <: Real\n\nsquared model-data misfit for pointwise data\ncontrols are a vector input for Optim.jl\nIssue #1: couldn't figure out how to nest with costfunction_obs!\n\nArguments\n\nJ: cost function of sum of squared misfits\nguvec: derivative of cost function wrt to controls\nuvec: controls, vector format\nAlu: LU decomposition of water-mass matrix\nb: boundary condition\ny: pointwise observations\nWⁱ: inverse of W weighting matrix for observations\nwis: weights for interpolation (data sampling, E)\nlocs: data locations (lon,lat,depth)\nQ⁻: weights for control vector\nγ: grid\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.steadyinversion","page":"Utilities","title":"TMI.steadyinversion","text":"function steadyinversion(Alu,b;q=nothing,r=1.0)\ninvert for a steady-state tracer distribution\n\nArguments\n\nAlu: LU decomposition of water-mass matrix\nb: boundary condition\nγ::Grid\n\nOptional Arguments\n\nq: interior sources/sinks of phosphate\nr: stochiometric ratio of tracer:phosphate\n\nOutput\n\nc::Field, steady-state tracer distribution\n\n\n\n\n\nfunction steadyinversion(Alu,b::NamedTuple{<:Any, NTuple{N,BoundaryCondition{T}}},γ::Grid;q=nothing,r=1.0)::Field{T} where {N, T <: Real}\n\nsteady inversion for b::NamedTuple\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.gsteadyinversion","page":"Utilities","title":"TMI.gsteadyinversion","text":"function gsteadyinversion(Alu,b;q=nothing,r=1.0)\n\nADJOINT invert for a steady-state tracer distribution\n\nArguments\n\nAlu: LU decomposition of water-mass matrix\nb: BoundaryCondition\nγ::Grid\n\nOptional Arguments\n\nq: interior sources/sinks of phosphate\nr: stochiometric ratio of tracer:phosphate\n\nOutput\n\nc::Field, steady-state tracer distribution\n\n\n\n\n\nfunction gsteadyinversion(gc::Field{T},Alu,b::NamedTuple{<:Any, NTuple{N,BoundaryCondition{T}}},γ::Grid;q=nothing,r=1.0)::Field{T} where {N, T <: Real}\n\nADDJOINT steady inversion for b::NamedTuple\n\n\n\n\n\n","category":"function"},{"location":"utils/#TMI.wetlocation","page":"Utilities","title":"TMI.wetlocation","text":"function wetlocation(γ)\nGet (lon,lat,depth) tuples of wet locations.\nAllow a location to be wet if at least one out of 8 nearby gridpoints is wet.\nCertainly \"wet\" gridpoints could be defined more strictly.\n\nArguments\n\nγ: TMI.grid\n\nOutput\n\nloc: lon,lat,depth \n\n\n\n\n\n","category":"function"},{"location":"boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"CurrentModule = TMI","category":"page"},{"location":"boundaries/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Boundary conditions for TMI.","category":"page"},{"location":"boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"TMI.BoundaryCondition\nTMI.getboundarycondition\nTMI.zerosurfaceboundary\nTMI.zeronorthboundary\nTMI.zeroeastboundary\nTMI.zerosouthboundary\nTMI.zerowestboundary\nTMI.onesurfaceboundary\nTMI.getsurfaceboundary\nTMI.getnorthboundary\nTMI.geteastboundary\nTMI.getsouthboundary\nTMI.getwestboundary\nTMI.setboundarycondition!\nTMI.gsetboundarycondition\nTMI.adjustboundarycondition!\nTMI.gadjustboundarycondition\nTMI.gadjustboundarycondition!","category":"page"},{"location":"boundaries/#TMI.BoundaryCondition","page":"Boundary Conditions","title":"TMI.BoundaryCondition","text":"struct BoundaryCondition\n\na plane defined at `dim=dimval`\n\nAttributes\n\n`tracer::Array{T,2}`: values on plane\n`i::Vector{T}`: coordinate values on local x-plane\n`j::Vector{T}`: coordinate values on local y-plane\n`k::T`: fixed coordinate value on local z-plane that defines the Boundary Condition plane\n`dim::Int64`: dimension (1,2, or 3) along which the plane's index is fixed\n`dimval::Int64`: plane defined at dim = dimval where dimval is a 1-based index number\n`wet::BitArray{2}`: ocean mask for boundary condition\n\n\n\n\n\n","category":"type"},{"location":"boundaries/#TMI.getboundarycondition","page":"Boundary Conditions","title":"TMI.getboundarycondition","text":"Get boundary condition by extracting from 3D tracer\n\n\n\n\n\nfunction getboundarycondition(field::Field,dim,dimval)::BoundaryCondition\n\nGet boundary condition by extracting from Field (i.e., 3D tracer)\n\nArguments\n\nfield::Field: 3D tracer field with metadata and grid\ndim: dimension number (1,2,3) that the boundary plane has constant value\ndimval: index number in dimension dim that defines boundary plane\n\nOutput\n\nb::BoundaryCondition: boundary condition on a plane with metadata and grid\n\n\n\n\n\n","category":"function"},{"location":"boundaries/#TMI.setboundarycondition!","page":"Boundary Conditions","title":"TMI.setboundarycondition!","text":"function setboundarycondition!(d::Field,b::BoundaryCondition)\napply boundary condition to the equation constraints\n\nArguments\n\nd::Field, equation constraints (i.e., right hand side)\nb::BoundaryCondition\n\n\n\n\n\nfunction setboundarycondition!(d::Field{T},b::NamedTuple{<:Any, NTuple{N,BoundaryCondition{T}}}) where {N, T <: Real}\n\nset all boundary conditions in a Named Tuple\n\n\n\n\n\n","category":"function"},{"location":"boundaries/#TMI.gsetboundarycondition","page":"Boundary Conditions","title":"TMI.gsetboundarycondition","text":"function gsetboundarycondition(gd::Field{T},b::BoundaryCondition{T}) where T<: Real\n\nADJOINT: apply boundary condition to the equation constraints\n\nArguments\n\nd::Field, equation constraints (i.e., right hand side)\nb::BoundaryCondition\n\n\n\n\n\nfunction gsetboundarycondition(gd::Field{T},b::BoundaryCondition{T}) where T<: Real\n\nADJOINT: apply boundary condition to the equation constraints\n\nArguments\n\nd::Field, equation constraints (i.e., right hand side)\nb::BoundaryCondition\n\n\n\n\n\n","category":"function"},{"location":"boundaries/#TMI.adjustboundarycondition!","page":"Boundary Conditions","title":"TMI.adjustboundarycondition!","text":"function adjustboundarycondition!(b::BoundaryCondition{T},u::BoundaryCondition{T}) where T <: Real\n\nadjust the (one) boundary condition \nproblem: passes back a mutated b\n\n\n\n\n\nfunction adjustboundarycondition!(b::NamedTuple{<:Any, NTuple{N1,BoundaryCondition{T}}},u::NamedTuple{<:Any, NTuple{N2,BoundaryCondition{T}}}) where N1, N2, T <: Real\n\nadjust all boundary conditions b that are described in u\n\n\n\n\n\n","category":"function"},{"location":"boundaries/#TMI.gadjustboundarycondition","page":"Boundary Conditions","title":"TMI.gadjustboundarycondition","text":"function gadjustboundarycondition!(b::BoundaryCondition{T},u::BoundaryCondition{T}) where T <: Real\n\nadjust the (one) boundary condition \nJust copy the variable.\nKeep this function so that calling functions can look alike.\nCould probably combine with lower function, use Union type\n\n\n\n\n\nfunction gadjustboundarycondition!(b::BoundaryCondition{T},u::BoundaryCondition{T}) where T <: Real\n\nADJOINT CODE\nadjust the (one) boundary condition \nJust copy the variable.\nKeep this function so that calling functions can look alike.\n\n\n\n\n\n","category":"function"}]
}
