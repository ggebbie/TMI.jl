<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function List · TMI.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ggebbie.github.io/TMI.jl/functions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TMI.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Top-level functions</a></li><li><a class="tocitem" href="../config/">Configuration</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../boundaries/">Boundary Conditions</a></li><li><a class="tocitem" href="../plots/">Plots</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li class="is-active"><a class="tocitem" href>Function List</a></li><li><a class="tocitem" href="../legacy/">Older functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function List</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function List</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ggebbie/TMI.jl/blob/main/docs/src/functions.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TMI"><a class="docs-heading-anchor" href="#TMI">TMI</a><a id="TMI-1"></a><a class="docs-heading-anchor-permalink" href="#TMI" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/ggebbie/TMI.jl">TMI</a>.</p><ul><li><a href="../boundaries/#TMI.BoundaryCondition"><code>TMI.BoundaryCondition</code></a></li><li><a href="#TMI.Field"><code>TMI.Field</code></a></li><li><a href="#TMI.Grid-Tuple{String}"><code>TMI.Grid</code></a></li><li><a href="#TMI.Grid"><code>TMI.Grid</code></a></li><li><a href="#TMI.Grid-Union{Tuple{S}, NTuple{5, S}} where S&lt;:String"><code>TMI.Grid</code></a></li><li><a href="#TMI.MassFraction"><code>TMI.MassFraction</code></a></li><li><a href="#TMI.Source"><code>TMI.Source</code></a></li><li><a href="#Base.:\\-Union{Tuple{T}, Tuple{Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>Base.:\</code></a></li><li><a href="#Base.length-Tuple{Union{BoundaryCondition, Field, TMI.Source}}"><code>Base.length</code></a></li><li><a href="#Base.one-Tuple{Type{Field}}"><code>Base.one</code></a></li><li><a href="#Base.one-Union{Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{T}} where T&lt;:Real"><code>Base.one</code></a></li><li><a href="#Base.ones"><code>Base.ones</code></a></li><li><a href="../utils/#Base.ones"><code>Base.ones</code></a></li><li><a href="#Base.ones-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer"><code>Base.ones</code></a></li><li><a href="#Base.propertynames-Tuple{Grid}"><code>Base.propertynames</code></a></li><li><a href="#Base.sum-Tuple{Field}"><code>Base.sum</code></a></li><li><a href="#Base.vec-Tuple{Field}"><code>Base.vec</code></a></li><li><a href="../utils/#Base.vec"><code>Base.vec</code></a></li><li><a href="#Base.zero-Tuple{Field}"><code>Base.zero</code></a></li><li><a href="#Base.zeros"><code>Base.zeros</code></a></li><li><a href="#Base.zeros-Union{Tuple{Grid{T}}, Tuple{T}, Tuple{Grid{T}, Any}, Tuple{Grid{T}, Any, Any}, Tuple{Grid{T}, Any, Any, Any}} where T&lt;:Real"><code>Base.zeros</code></a></li><li><a href="#Base.zeros-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer"><code>Base.zeros</code></a></li><li><a href="../utils/#Base.zeros"><code>Base.zeros</code></a></li><li><a href="#LinearAlgebra.dot-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>LinearAlgebra.dot</code></a></li><li><a href="#TMI.add!-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Union{BoundaryCondition, Field, TMI.Source}"><code>TMI.add!</code></a></li><li><a href="#TMI.adjustboundarycondition-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.adjustboundarycondition</code></a></li><li><a href="#TMI.adjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.adjustboundarycondition!</code></a></li><li><a href="../boundaries/#TMI.adjustboundarycondition!"><code>TMI.adjustboundarycondition!</code></a></li><li><a href="#TMI.axislabels-Tuple{String}"><code>TMI.axislabels</code></a></li><li><a href="#TMI.boundaryconditionatts-Union{Tuple{N}, Tuple{R}, Tuple{Integer, Integer, Grid{R, N}}} where {R, N}"><code>TMI.boundaryconditionatts</code></a></li><li><a href="#TMI.boundarymask-Tuple{Grid}"><code>TMI.boundarymask</code></a></li><li><a href="../config/#TMI.boundarymatrix"><code>TMI.boundarymatrix</code></a></li><li><a href="#TMI.boundarymatrix-Tuple{Any, Any}"><code>TMI.boundarymatrix</code></a></li><li><a href="../config/#TMI.boundarymatrix2nc"><code>TMI.boundarymatrix2nc</code></a></li><li><a href="#TMI.boundarymatrix2nc-Tuple{Any, Any}"><code>TMI.boundarymatrix2nc</code></a></li><li><a href="../config/#TMI.cartesianindex"><code>TMI.cartesianindex</code></a></li><li><a href="#TMI.cartesianindex-Tuple{String}"><code>TMI.cartesianindex</code></a></li><li><a href="#TMI.cartesianindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N"><code>TMI.cartesianindex</code></a></li><li><a href="../grid/#TMI.cellarea"><code>TMI.cellarea</code></a></li><li><a href="#TMI.cellarea-Tuple{Any}"><code>TMI.cellarea</code></a></li><li><a href="#TMI.cellvolume-Tuple{Any}"><code>TMI.cellvolume</code></a></li><li><a href="../grid/#TMI.cellvolume"><code>TMI.cellvolume</code></a></li><li><a href="#TMI.checkgrid!-Tuple{Any, Any}"><code>TMI.checkgrid!</code></a></li><li><a href="#TMI.circulationmatrix-Tuple{Any, Any}"><code>TMI.circulationmatrix</code></a></li><li><a href="#TMI.circulationmatrix-Tuple{Any, Any, Any}"><code>TMI.circulationmatrix</code></a></li><li><a href="../config/#TMI.circulationmatrix"><code>TMI.circulationmatrix</code></a></li><li><a href="../config/#TMI.circulationmatrix2nc"><code>TMI.circulationmatrix2nc</code></a></li><li><a href="#TMI.circulationmatrix2nc-Tuple{Any, Any, Any}"><code>TMI.circulationmatrix2nc</code></a></li><li><a href="#TMI.config-Tuple{Any}"><code>TMI.config</code></a></li><li><a href="../config/#TMI.config2nc"><code>TMI.config2nc</code></a></li><li><a href="#TMI.config2nc-NTuple{5, Any}"><code>TMI.config2nc</code></a></li><li><a href="../legacy/#TMI.control2state"><code>TMI.control2state</code></a></li><li><a href="#TMI.control2state-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T&lt;:Real"><code>TMI.control2state</code></a></li><li><a href="#TMI.costfunction_gridded_model-Union{Tuple{T}, Tuple{Any, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real"><code>TMI.costfunction_gridded_model</code></a></li><li><a href="#TMI.costfunction_gridded_model!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real"><code>TMI.costfunction_gridded_model!</code></a></li><li><a href="#TMI.costfunction_point_obs-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}"><code>TMI.costfunction_point_obs</code></a></li><li><a href="../utils/#TMI.costfunction_point_obs"><code>TMI.costfunction_point_obs</code></a></li><li><a href="#TMI.costfunction_point_obs!-Tuple{Any, Union{Nothing, Vector}, Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}"><code>TMI.costfunction_point_obs!</code></a></li><li><a href="../utils/#TMI.costfunction_point_obs!"><code>TMI.costfunction_point_obs!</code></a></li><li><a href="#TMI.depthindex-Tuple{Any}"><code>TMI.depthindex</code></a></li><li><a href="../grid/#TMI.depthindex"><code>TMI.depthindex</code></a></li><li><a href="#TMI.dirichletmatrix-Tuple{Grid, Any}"><code>TMI.dirichletmatrix</code></a></li><li><a href="#TMI.distancematrix-Tuple{Any}"><code>TMI.distancematrix</code></a></li><li><a href="#TMI.download_file-Tuple{String}"><code>TMI.download_file</code></a></li><li><a href="#TMI.download_regionfile-Tuple{String}"><code>TMI.download_regionfile</code></a></li><li><a href="#TMI.eastindex-Tuple{Any}"><code>TMI.eastindex</code></a></li><li><a href="../grid/#TMI.eastindex"><code>TMI.eastindex</code></a></li><li><a href="#TMI.effective_endmember-Tuple{Any, Any, Field, Any, Grid}"><code>TMI.effective_endmember</code></a></li><li><a href="#TMI.effective_endmember_sums-Tuple{Any, Field, BoundaryCondition, Grid}"><code>TMI.effective_endmember_sums</code></a></li><li><a href="../config/#TMI.fieldsatts"><code>TMI.fieldsatts</code></a></li><li><a href="#TMI.fieldsatts-Tuple{}"><code>TMI.fieldsatts</code></a></li><li><a href="../boundaries/#TMI.gadjustboundarycondition!"><code>TMI.gadjustboundarycondition!</code></a></li><li><a href="#TMI.gadjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.gadjustboundarycondition!</code></a></li><li><a href="#TMI.gaussiandistancematrix-Tuple{Any, Any, Any}"><code>TMI.gaussiandistancematrix</code></a></li><li><a href="#TMI.getboundarycondition-Tuple{Field, Integer, Integer}"><code>TMI.getboundarycondition</code></a></li><li><a href="../boundaries/#TMI.getboundarycondition"><code>TMI.getboundarycondition</code></a></li><li><a href="#TMI.getboundarycondition-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{Field{T, R, N, F} where F&lt;:AbstractArray{T, N}, Integer, Integer, Grid}} where {T&lt;:Real, R&lt;:Real, N}"><code>TMI.getboundarycondition</code></a></li><li><a href="../utils/#TMI.gobserve"><code>TMI.gobserve</code></a></li><li><a href="#TMI.gobserve-Union{Tuple{T}, Tuple{Vector{T}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.gobserve</code></a></li><li><a href="#TMI.grid2nc-Tuple{Any, Any}"><code>TMI.grid2nc</code></a></li><li><a href="../config/#TMI.grid2nc"><code>TMI.grid2nc</code></a></li><li><a href="../config/#TMI.griddicts"><code>TMI.griddicts</code></a></li><li><a href="#TMI.griddicts-Tuple{Any}"><code>TMI.griddicts</code></a></li><li><a href="#TMI.gridsize-Tuple{Any}"><code>TMI.gridsize</code></a></li><li><a href="../boundaries/#TMI.gsetboundarycondition"><code>TMI.gsetboundarycondition</code></a></li><li><a href="#TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>TMI.gsetboundarycondition</code></a></li><li><a href="#TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, NamedTuple}} where T&lt;:Real"><code>TMI.gsetboundarycondition</code></a></li><li><a href="#TMI.gsetsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.gsetsource!</code></a></li><li><a href="#TMI.gsteadyinversion-Tuple{Field, Any, Union{NamedTuple, BoundaryCondition}, Grid}"><code>TMI.gsteadyinversion</code></a></li><li><a href="../utils/#TMI.gsteadyinversion"><code>TMI.gsteadyinversion</code></a></li><li><a href="../grid/#TMI.horizontaldistance"><code>TMI.horizontaldistance</code></a></li><li><a href="#TMI.horizontaldistance-Tuple{Any, Grid}"><code>TMI.horizontaldistance</code></a></li><li><a href="#TMI.interiormask-NTuple{5, Any}"><code>TMI.interiormask</code></a></li><li><a href="#TMI.interpindex-Tuple{Any, Any}"><code>TMI.interpindex</code></a></li><li><a href="../grid/#TMI.interpindex"><code>TMI.interpindex</code></a></li><li><a href="../grid/#TMI.interpweights"><code>TMI.interpweights</code></a></li><li><a href="#TMI.interpweights-Tuple{Any, Any}"><code>TMI.interpweights</code></a></li><li><a href="#TMI.latindex-Tuple{Any}"><code>TMI.latindex</code></a></li><li><a href="../grid/#TMI.latindex"><code>TMI.latindex</code></a></li><li><a href="../grid/#TMI.linearindex"><code>TMI.linearindex</code></a></li><li><a href="#TMI.linearindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N"><code>TMI.linearindex</code></a></li><li><a href="#TMI.local_watermass_matrix-Tuple{NamedTuple, Union{NamedTuple, Vector}, CartesianIndex, Field}"><code>TMI.local_watermass_matrix</code></a></li><li><a href="#TMI.lonindex-Tuple{Any}"><code>TMI.lonindex</code></a></li><li><a href="../grid/#TMI.lonindex"><code>TMI.lonindex</code></a></li><li><a href="#TMI.matfields2nc_orig-Tuple{Any, Any}"><code>TMI.matfields2nc_orig</code></a></li><li><a href="#TMI.meanage-Tuple{Any, Any, Any}"><code>TMI.meanage</code></a></li><li><a href="../#TMI.meanage"><code>TMI.meanage</code></a></li><li><a href="#TMI.mixedlayermask-Tuple{Any, Grid}"><code>TMI.mixedlayermask</code></a></li><li><a href="#TMI.mixedlayermatrix-Tuple{Any, Any, Any}"><code>TMI.mixedlayermatrix</code></a></li><li><a href="#TMI.ncurl-Tuple{Any}"><code>TMI.ncurl</code></a></li><li><a href="../config/#TMI.ncurl"><code>TMI.ncurl</code></a></li><li><a href="#TMI.nearestneighbor"><code>TMI.nearestneighbor</code></a></li><li><a href="../utils/#TMI.nearestneighbor"><code>TMI.nearestneighbor</code></a></li><li><a href="#TMI.nearestneighbormask"><code>TMI.nearestneighbormask</code></a></li><li><a href="../utils/#TMI.nearestneighbormask"><code>TMI.nearestneighbormask</code></a></li><li><a href="#TMI.neighbor_indices"><code>TMI.neighbor_indices</code></a></li><li><a href="#TMI.neighbors-Union{Tuple{N}, Tuple{R}, Tuple{Union{NamedTuple, Vector}, Grid{R, N}}} where {R, N}"><code>TMI.neighbors</code></a></li><li><a href="#TMI.neighbors-Union{Tuple{Grid{R, N}}, Tuple{N}, Tuple{R}} where {R, N}"><code>TMI.neighbors</code></a></li><li><a href="#TMI.northindex-Tuple{Any}"><code>TMI.northindex</code></a></li><li><a href="../grid/#TMI.northindex"><code>TMI.northindex</code></a></li><li><a href="../utils/#TMI.observe"><code>TMI.observe</code></a></li><li><a href="#TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{T, T, T}, 1}, Grid}} where T&lt;:Real"><code>TMI.observe</code></a></li><li><a href="#TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}}, 1}, Grid}} where T&lt;:Real"><code>TMI.observe</code></a></li><li><a href="../config/#TMI.optim2nc"><code>TMI.optim2nc</code></a></li><li><a href="#TMI.optim2nc-Tuple{Any}"><code>TMI.optim2nc</code></a></li><li><a href="#TMI.preformedcarbon13-Tuple{Any, Any, Any}"><code>TMI.preformedcarbon13</code></a></li><li><a href="#TMI.preformednitrate-Tuple{Any, Any, Any}"><code>TMI.preformednitrate</code></a></li><li><a href="#TMI.preformednutrient-Tuple{Union{String, Symbol}, Any, Any, Any}"><code>TMI.preformednutrient</code></a></li><li><a href="#TMI.preformedoxygen-Tuple{Any, Any, Any}"><code>TMI.preformedoxygen</code></a></li><li><a href="#TMI.preformedphosphate-Tuple{Any, Any, Any}"><code>TMI.preformedphosphate</code></a></li><li><a href="#TMI.readfield-Union{Tuple{N}, Tuple{A}, Tuple{Any, Any, Grid{A, N}}} where {A, N}"><code>TMI.readfield</code></a></li><li><a href="#TMI.readtracer-Tuple{Any, Any}"><code>TMI.readtracer</code></a></li><li><a href="#TMI.regeneratednutrient-NTuple{4, Any}"><code>TMI.regeneratednutrient</code></a></li><li><a href="#TMI.regions_mat2nc-Tuple{Any, Any}"><code>TMI.regions_mat2nc</code></a></li><li><a href="#TMI.regionurl-Tuple{Any}"><code>TMI.regionurl</code></a></li><li><a href="../plots/#TMI.section"><code>TMI.section</code></a></li><li><a href="#TMI.section-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.section</code></a></li><li><a href="../boundaries/#TMI.setboundarycondition!"><code>TMI.setboundarycondition!</code></a></li><li><a href="#TMI.setboundarycondition!-Tuple{Field, BoundaryCondition}"><code>TMI.setboundarycondition!</code></a></li><li><a href="#TMI.setboundarycondition!-Tuple{Field, NamedTuple}"><code>TMI.setboundarycondition!</code></a></li><li><a href="#TMI.setsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.setsource!</code></a></li><li><a href="#TMI.shiftloc-Tuple{Any, Any}"><code>TMI.shiftloc</code></a></li><li><a href="../grid/#TMI.shiftloc"><code>TMI.shiftloc</code></a></li><li><a href="#TMI.southindex-Tuple{Any}"><code>TMI.southindex</code></a></li><li><a href="../grid/#TMI.southindex"><code>TMI.southindex</code></a></li><li><a href="#TMI.sparsedatamap_optim-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, Any, Vector, Any, Any, Grid}"><code>TMI.sparsedatamap_optim</code></a></li><li><a href="#TMI.steadyclimatology_optim-Tuple{Any, Any, Any}"><code>TMI.steadyclimatology_optim</code></a></li><li><a href="#TMI.steadyinversion-Union{Tuple{T}, Tuple{Any, BoundaryCondition, Grid{T}}} where T&lt;:Real"><code>TMI.steadyinversion</code></a></li><li><a href="../utils/#TMI.steadyinversion"><code>TMI.steadyinversion</code></a></li><li><a href="#TMI.step_cartesian-Union{Tuple{N}, Tuple{R}, Tuple{CartesianIndex{N}, CartesianIndex{N}, Grid{R, N}}} where {R, N}"><code>TMI.step_cartesian</code></a></li><li><a href="#TMI.surfacecontrol2field-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field</code></a></li><li><a href="../legacy/#TMI.surfacecontrol2field"><code>TMI.surfacecontrol2field</code></a></li><li><a href="#TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field!</code></a></li><li><a href="../legacy/#TMI.surfacecontrol2field!"><code>TMI.surfacecontrol2field!</code></a></li><li><a href="#TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field!</code></a></li><li><a href="../grid/#TMI.surfaceindex"><code>TMI.surfaceindex</code></a></li><li><a href="#TMI.surfaceindex-Tuple{Any}"><code>TMI.surfaceindex</code></a></li><li><a href="../#TMI.surfaceorigin"><code>TMI.surfaceorigin</code></a></li><li><a href="#TMI.surfaceorigin-Tuple{Any, Any, Grid}"><code>TMI.surfaceorigin</code></a></li><li><a href="../grid/#TMI.surfacepatch"><code>TMI.surfacepatch</code></a></li><li><a href="#TMI.surfacepatch-Union{Tuple{R}, Tuple{Any, Any, Grid{R, 3}}} where R"><code>TMI.surfacepatch</code></a></li><li><a href="../config/#TMI.surfaceregion"><code>TMI.surfaceregion</code></a></li><li><a href="#TMI.surfaceregion-Tuple{String, Union{String, Symbol}}"><code>TMI.surfaceregion</code></a></li><li><a href="#TMI.surfaceregion-Tuple{String, Union{String, Symbol}, Grid}"><code>TMI.surfaceregion</code></a></li><li><a href="../utils/#TMI.synthetic_observations"><code>TMI.synthetic_observations</code></a></li><li><a href="#TMI.synthetic_observations"><code>TMI.synthetic_observations</code></a></li><li><a href="#TMI.synthetic_observations-Tuple{Any, Any, Any}"><code>TMI.synthetic_observations</code></a></li><li><a href="../utils/#TMI.tracerinit"><code>TMI.tracerinit</code></a></li><li><a href="#TMI.tracerinit-Tuple{Any, Any, Any}"><code>TMI.tracerinit</code></a></li><li><a href="../#TMI.trackpathways"><code>TMI.trackpathways</code></a></li><li><a href="#TMI.trackpathways-NTuple{4, Any}"><code>TMI.trackpathways</code></a></li><li><a href="#TMI.unvec-Tuple{Union{NamedTuple, BoundaryCondition, Field}, Vector}"><code>TMI.unvec</code></a></li><li><a href="../utils/#TMI.unvec"><code>TMI.unvec</code></a></li><li><a href="#TMI.unvec!-Union{Tuple{T}, Tuple{Union{BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Vector{T}}} where T&lt;:Real"><code>TMI.unvec!</code></a></li><li><a href="../utils/#TMI.unvec!"><code>TMI.unvec!</code></a></li><li><a href="#TMI.vec2fld-Union{Tuple{T}, Tuple{Vector{T}, Vector{CartesianIndex{3}}}} where T&lt;:Real"><code>TMI.vec2fld</code></a></li><li><a href="../#TMI.volumefilled"><code>TMI.volumefilled</code></a></li><li><a href="#TMI.volumefilled-Tuple{Any, Any, Any}"><code>TMI.volumefilled</code></a></li><li><a href="#TMI.watermassdistribution-NTuple{4, Any}"><code>TMI.watermassdistribution</code></a></li><li><a href="../#TMI.watermassdistribution"><code>TMI.watermassdistribution</code></a></li><li><a href="../config/#TMI.watermassmatrix"><code>TMI.watermassmatrix</code></a></li><li><a href="#TMI.watermassmatrix-Tuple{Any}"><code>TMI.watermassmatrix</code></a></li><li><a href="#TMI.watermassmatrix-Tuple{Union{NamedTuple, Vector}, Grid}"><code>TMI.watermassmatrix</code></a></li><li><a href="../grid/#TMI.westindex"><code>TMI.westindex</code></a></li><li><a href="#TMI.westindex-Tuple{Any}"><code>TMI.westindex</code></a></li><li><a href="#TMI.wetlocation-Tuple{Any}"><code>TMI.wetlocation</code></a></li><li><a href="../utils/#TMI.wetlocation"><code>TMI.wetlocation</code></a></li><li><a href="#TMI.write-Union{Tuple{T}, Tuple{R}, Tuple{N}, Tuple{B}, Tuple{Any, BoundaryCondition{T, R, N, B, B1} where B1&lt;:AbstractArray{T, N}}} where {B&lt;:(AbstractMatrix), N&lt;:Integer, R&lt;:Real, T&lt;:Real}"><code>TMI.write</code></a></li><li><a href="#TMI.write-Union{Tuple{T}, Tuple{Any, Union{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}}} where T&lt;:Real"><code>TMI.write</code></a></li><li><a href="#TMI.Γsfc!"><code>TMI.Γsfc!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TMI.Field" href="#TMI.Field"><code>TMI.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Field

This structure permits the grid to be 
automatically passed to functions with
the tracer field.

This structure assumes the Tracer type to be 
three-dimensional.

tracer::AbstractArray{T,N}
γ::Grid{A,N}
name::Symbol
longname::String
units::String</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/field.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.Grid" href="#TMI.Grid"><code>TMI.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Grid</code></pre><p>TMI grid with accounting for wet/dry points</p><p><strong>Fields</strong></p><ul><li><code>axes::NTuple{N,Vector{A}}</code>: labels for axis such as lon, lat, depth with element type <code>A</code></li><li><code>wet::BitArray{N}</code>: mask for ocean points</li><li><code>interior::BitArray{N}</code>: mask for interior ocean points</li><li><code>wrap::NTuple{N,Bool}</code>: does the domain wraparound in each dim?</li><li><code>Δ::Vector{CartesianIndex{N}}</code>: defines computational stencil relative to central cell</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/grid.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.Grid-Tuple{String}" href="#TMI.Grid-Tuple{String}"><code>TMI.Grid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function Grid(TMIfile)</p><pre><code class="nohighlight hljs">Construct the Grid given a file name</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIfile::String</code>: NetCDF file name for TMI version</li></ul><p><strong>Output</strong></p><ul><li><code>γ::Grid</code>: TMI grid struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/grid.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.Grid-Union{Tuple{S}, NTuple{5, S}} where S&lt;:String" href="#TMI.Grid-Union{Tuple{S}, NTuple{5, S}} where S&lt;:String"><code>TMI.Grid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function Grid(foreign_file, maskname, lonname, latname, depthname)</p><pre><code class="nohighlight hljs">Construct the Grid from a non-TMI file given the names of relevant fields.

Assumes that an ocean mask is available.
Assumes an input NetCDF file.
Assumes everything below the top layer is part of the interior. 
Tested for Float32 fields (should work for other types).</code></pre><p><strong>Arguments</strong></p><ul><li><code>foreign_file::String</code></li><li><code>maskname::String</code></li><li><code>lonname::String</code></li><li><code>latname::String</code></li><li><code>depthname::String</code></li></ul><p><strong>Output</strong></p><ul><li><code>γ::Grid</code>: TMI grid struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/grid.jl#L52-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.MassFraction" href="#TMI.MassFraction"><code>TMI.MassFraction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct MassFraction</p><p>store mass fractions in a Field-like array</p><ul><li><code>fraction::Array{T,3}</code></li><li><code>γ::Grid</code></li><li><code>name::Symbol</code></li><li><code>longname::String</code></li><li><code>units::String</code></li><li><code>position::CartesianIndex{3}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/mass_fractions.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.Source" href="#TMI.Source"><code>TMI.Source</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Source

This structure describes Sources, which are
similar to Fields, but they may be
1) non-negative
2) have only interior mask</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/source.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Union{Tuple{T}, Tuple{Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real" href="#Base.:\\-Union{Tuple{T}, Tuple{Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`function \(A,d::Field)::Field`
Define left division for Fields
Need two slashes to prevent invalid escape</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1132-L1136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{Union{BoundaryCondition, Field, TMI.Source}}" href="#Base.length-Tuple{Union{BoundaryCondition, Field, TMI.Source}}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.length(c::Union{Field,Source,BoundaryCondition}) = length(c.tracer[wet(c)])

Extend `length` to give the number of wet (i.e., ocean) gridcells.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1105-L1109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.one-Tuple{Type{Field}}" href="#Base.one-Tuple{Type{Field}}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function oneunit, help for gridded Interpolations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1002-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.one-Union{Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{T}} where T&lt;:Real" href="#Base.one-Union{Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{T}} where T&lt;:Real"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function oneunit, help for gridded Interpolations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L978-L981">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ones" href="#Base.ones"><code>Base.ones</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function ones(γ::Grid,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;)::Field

  initialize tracer field of ones on TMI grid
  using a Field struct and constructor</code></pre><p><strong>Arguments</strong></p><ul><li><code>γ</code>::TMI.Grid</li></ul><p><strong>Output</strong></p><ul><li><code>d</code>::Field,  3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L950-L960">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ones-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer" href="#Base.ones-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer"><code>Base.ones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function ones(dim::Int64,dimval::Int64,γ::Grid)::BoundaryCondition

   Initialize boundary condition with ones</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.propertynames-Tuple{Grid}" href="#Base.propertynames-Tuple{Grid}"><code>Base.propertynames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.propertynames(γ::Grid) = (I,R,fieldnames(typeof(x))...)

Do not store Cartesian and linear indices.
Compute them on demand.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/grid.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{Field}" href="#Base.sum-Tuple{Field}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Specialize Base.sum(c::Field)

so that it doesn&#39;t use the slow iteration method</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1125-L1129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vec-Tuple{Field}" href="#Base.vec-Tuple{Field}"><code>Base.vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function vec(u)

Turn a collection of controls into a vector
for use with Optim.jl. 
An in-place version of this function would be handy.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1270-L1276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zero-Tuple{Field}" href="#Base.zero-Tuple{Field}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero(c::Field) = zeros(c.γ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1095-L1097">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros" href="#Base.zeros"><code>Base.zeros</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function zeros(wet,ltype=Float64)
initialize tracer field on TMI grid
This version will give an array</code></pre><p><strong>Arguments</strong></p><ul><li><code>wet</code>::BitArray mask of ocean points</li><li><code>ltype</code>:: optional type argument, default=Float64</li></ul><p><strong>Output</strong></p><ul><li><code>d</code>:: 3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1074-L1084">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros-Union{Tuple{Grid{T}}, Tuple{T}, Tuple{Grid{T}, Any}, Tuple{Grid{T}, Any, Any}, Tuple{Grid{T}, Any, Any, Any}} where T&lt;:Real" href="#Base.zeros-Union{Tuple{Grid{T}}, Tuple{T}, Tuple{Grid{T}, Any}, Tuple{Grid{T}, Any, Any}, Tuple{Grid{T}, Any, Any, Any}} where T&lt;:Real"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function zeros(γ::Grid,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;)::Field

  initialize tracer field on TMI grid
  using a Field struct and constructor</code></pre><p><strong>Arguments</strong></p><ul><li><code>γ</code>::TMI.Grid</li></ul><p><strong>Output</strong></p><ul><li><code>d</code>::Field,  3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/field.jl#L33-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer" href="#Base.zeros-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function zeros(dim::Int64,dimval::Int64,γ::Grid,name::Symbol,longname::String,units::String)::BoundaryCondition

   Initialize boundary condition with zeroes</code></pre><p><strong>Arguments</strong></p><ul><li><code>dim</code>:</li><li><code>dimval</code></li><li><code>γ::Grid</code></li><li><code>name::Symbol</code></li><li><code>longname::String</code></li><li><code>units::String</code></li></ul><p><strong>Output</strong></p><ul><li><code>b::BoundaryCondition</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L180-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real" href="#LinearAlgebra.dot-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`function *(c::Field,d::Field)::Field`
Field by field multiplication is element-by-element.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1229-L1232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.add!-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Union{BoundaryCondition, Field, TMI.Source}" href="#TMI.add!-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Union{BoundaryCondition, Field, TMI.Source}"><code>TMI.add!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`function +(c::BoundaryCondition,d::BoundaryCondition)::BoundaryCondition`
Define addition for Fields</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1144-L1147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.adjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}" href="#TMI.adjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.adjustboundarycondition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function adjustboundarycondition!(b::Union{BoundaryCondition,NamedTuple},u::Union{BoundaryCondition,NamedTuple})

adjust all boundary conditions b that are described in u

warning: if u doesn&#39;t contain any boundary condition adjustments,
nothing will change.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L409-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.adjustboundarycondition-Tuple{BoundaryCondition, BoundaryCondition}" href="#TMI.adjustboundarycondition-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.adjustboundarycondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function adjustboundarycondition!(b::Union{BoundaryCondition,NamedTuple},u::Union{BoundaryCondition,NamedTuple})

adjust all boundary conditions b that are described in u</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L397-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.axislabels-Tuple{String}" href="#TMI.axislabels-Tuple{String}"><code>TMI.axislabels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function axislabels(file)
Read and assemble the grid properties.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li></ul><p><strong>Output</strong></p><ul><li><code>grid</code>: TMI grid coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L99-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.boundaryconditionatts-Union{Tuple{N}, Tuple{R}, Tuple{Integer, Integer, Grid{R, N}}} where {R, N}" href="#TMI.boundaryconditionatts-Union{Tuple{N}, Tuple{R}, Tuple{Integer, Integer, Grid{R, N}}} where {R, N}"><code>TMI.boundaryconditionatts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function boundaryconditionatts(dim::Int64,dimval::Int64,γ::Grid)

   Help initialize boundary condition by getting some attributes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.boundarymask-Tuple{Grid}" href="#TMI.boundarymask-Tuple{Grid}"><code>TMI.boundarymask</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function boundarymask(γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/grid.jl#L235-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.boundarymatrix-Tuple{Any, Any}" href="#TMI.boundarymatrix-Tuple{Any, Any}"><code>TMI.boundarymatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    function boundarymatrix(file,γ)
Read and assemble the boundary matrix from MATLAB.
Transfer to updated x,y,z version</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI MATLAB file name</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>B</code>: boundary condition matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L223-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.boundarymatrix2nc-Tuple{Any, Any}" href="#TMI.boundarymatrix2nc-Tuple{Any, Any}"><code>TMI.boundarymatrix2nc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Save boundary matrix for transient model to NetCDF file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L546-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.cartesianindex-Tuple{String}" href="#TMI.cartesianindex-Tuple{String}"><code>TMI.cartesianindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function cartesianindex(file)
Read and assemble the grid coordinates
according to the legacy MATLAB code (z,y,x order).</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li></ul><p><strong>Output</strong></p><ul><li><code>I</code>: TMI Cartesian index for wet points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L82-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.cartesianindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N" href="#TMI.cartesianindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N"><code>TMI.cartesianindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function cartesianindex(wet)
Read and assemble the grid coordinates
according to a 3D tracer in x,y,z order</code></pre><p><strong>Arguments</strong></p><ul><li><code>wet</code>: BitArray logical mask for wet points</li></ul><p><strong>Output</strong></p><ul><li><code>I</code>: 3D Cartesian indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/grid.jl#L120-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.cellarea-Tuple{Any}" href="#TMI.cellarea-Tuple{Any}"><code>TMI.cellarea</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Horizontal area of grid cell</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L629-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.cellvolume-Tuple{Any}" href="#TMI.cellvolume-Tuple{Any}"><code>TMI.cellvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function cellvolume(γ)::Field

Volume of each grid cell.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L703-L707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.checkgrid!-Tuple{Any, Any}" href="#TMI.checkgrid!-Tuple{Any, Any}"><code>TMI.checkgrid!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function checkgrid!(c,wet)

perform a check of file compatibility
 with grid</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/grid.jl#L153-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.circulationmatrix-Tuple{Any, Any, Any}" href="#TMI.circulationmatrix-Tuple{Any, Any, Any}"><code>TMI.circulationmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function circulationmatrix(file,A,γ)
Read and assemble the circulation matrix from the efficient storage of A and F₀ variables.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI MATLAB file name</li><li><code>A</code>: TMI water-mass matrix</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>L</code>: circulation matrix in xyz format</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L189-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.circulationmatrix-Tuple{Any, Any}" href="#TMI.circulationmatrix-Tuple{Any, Any}"><code>TMI.circulationmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function circulationmatrix(file,γ)
Read and assemble the circulation matrix from NetCDF.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI MATLAB file name</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>L</code>: circulation matrix in xyz format</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L166-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.circulationmatrix2nc-Tuple{Any, Any, Any}" href="#TMI.circulationmatrix2nc-Tuple{Any, Any, Any}"><code>TMI.circulationmatrix2nc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Save circulation matrix <code>L</code> to NetCDF file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L496-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.config-Tuple{Any}" href="#TMI.config-Tuple{Any}"><code>TMI.config</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function config(TMIversion; compute_lu = true)
Configure TMI environment from NetCDF input file.</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: TMI version for water-mass/circulation model</li></ul><p><strong>Output</strong></p><ul><li><code>A</code>: TMI steady-state water-mass matrix</li><li><code>Alu</code>: LU decomposition of A</li><li><code>γ</code>: TMI grid properties</li><li><code>TMIfile</code>: TMI file name</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.config2nc-NTuple{5, Any}" href="#TMI.config2nc-NTuple{5, Any}"><code>TMI.config2nc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Save TMI configuration to NetCDF format for non-proprietary access</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L335-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.control2state-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T&lt;:Real" href="#TMI.control2state-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T&lt;:Real"><code>TMI.control2state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function control2state(tracer2D,γ)
turn 2D surface field into 3D field with zeroes below surface</code></pre><p><strong>Arguments</strong></p><ul><li><code>tracer2D</code>:: 2D surface tracer field</li><li><code>wet</code>::BitArray mask of ocean points</li></ul><p><strong>Output</strong></p><ul><li><code>tracer3D</code>:: 3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/deprecated.jl#L91-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.costfunction_gridded_model!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real" href="#TMI.costfunction_gridded_model!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real"><code>TMI.costfunction_gridded_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function costfunction_gridded_model!(J,guvec,convec::Vector{T},non_zero_indices,u₀::Union{BoundaryCondition{T},NamedTuple{&lt;:Any, NTuple{N2,BoundaryCondition{T}}}},c,y::Field{T},Wⁱ::Diagonal{T, Vector{T}},Qⁱ::Diagonal{T, Vector{T}},γ::Grid) where {N1, N2, T &lt;: Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1756-L1758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.costfunction_gridded_model-Union{Tuple{T}, Tuple{Any, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real" href="#TMI.costfunction_gridded_model-Union{Tuple{T}, Tuple{Any, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real"><code>TMI.costfunction_gridded_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function costfunction_gridded_model(convec::Vector{T},non_zero_indices,y::Field{T},u,A0,c,q,Wⁱ::Diagonal{T, Vector{T}},Qⁱ::Diagonal{T, Vector{T}},γ::Grid) where T &lt;: Real

squared model-data misfit for gridded data
controls are a vector input for Optim.jl</code></pre><p><strong>Arguments</strong></p><ul><li><code>convec</code>: concatenated control vecotr incuding u and f</li><li><code>J</code>: cost function of sum of squared misfits</li><li><code>gJ</code>: derivative of cost function wrt to controls</li><li><code>u</code>: tracer controls, field format</li><li><code>non_zero_indices</code>: Non-zero indices for reconstruction of water-mass matrix A</li><li><code>c</code>: tracer concentrations from GCM</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>Qⁱ</code>: inverse of Q weighting matrix for tracer conservation</li><li><code>γ</code>: grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1691-L1707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.costfunction_point_obs!-Tuple{Any, Union{Nothing, Vector}, Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}" href="#TMI.costfunction_point_obs!-Tuple{Any, Union{Nothing, Vector}, Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}"><code>TMI.costfunction_point_obs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function costfunction_point_obs!(J,guvec,uvec::Vector{T},Alu,b₀::BoundaryCondition{T},u₀::BoundaryCondition{T},y::Vector{T},Wⁱ::Diagonal{T, Vector{T}},wis,locs,Q⁻,γ::Grid) where T &lt;: Real

squared model-data misfit for pointwise data
controls are a vector input for Optim.jl
Issue #1: couldn&#39;t figure out how to nest with costfunction_obs!</code></pre><p><strong>Arguments</strong></p><ul><li><code>J</code>: cost function of sum of squared misfits</li><li><code>guvec</code>: derivative of cost function wrt to controls</li><li><code>uvec</code>: controls, vector format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>b</code>: boundary condition</li><li><code>y</code>: pointwise observations</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>wis</code>: weights for interpolation (data sampling, E)</li><li><code>locs</code>: data locations (lon,lat,depth)</li><li><code>Q⁻</code>: weights for control vector</li><li><code>γ</code>: grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1619-L1639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.costfunction_point_obs-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}" href="#TMI.costfunction_point_obs-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}"><code>TMI.costfunction_point_obs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function costfunction_point_obs(uvec::Vector{T},Alu,b₀::BoundaryCondition{T},u₀::BoundaryCondition{T},y::Vector{T},Wⁱ::Diagonal{T, Vector{T}},wis,locs,Q⁻,γ::Grid;q=nothing,r=1.0) where T &lt;: Real

Squared model-data misfit for pointwise data.
Controls are a vector input for Optim.jl.
Core numerics handled by `costfunction_point_obs`.</code></pre><p><strong>Arguments</strong></p><ul><li><code>uvec</code>: controls, vector format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>b</code>: boundary condition</li><li><code>y</code>: pointwise observations</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>wis</code>: weights for interpolation (data sampling, E)</li><li><code>locs</code>: data locations (lon,lat,depth)</li><li><code>Q⁻</code>: weights for control vector</li><li><code>γ</code>: grid</li></ul><p><strong>Optional</strong></p><ul><li><code>q::Field</code>: interior source</li><li><code>r::Number</code>: scalar factor for source</li></ul><p><strong>Output</strong></p><ul><li><code>J</code>: cost function of sum of squared misfits</li><li><code>gJ</code>: derivative of cost function wrt to controls</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1585-L1609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.depthindex-Tuple{Any}" href="#TMI.depthindex-Tuple{Any}"><code>TMI.depthindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function depthindex(I) 
Get the k-index (depth level) from the Cartesian index</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L561-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.dirichletmatrix-Tuple{Grid, Any}" href="#TMI.dirichletmatrix-Tuple{Grid, Any}"><code>TMI.dirichletmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> function dirichletmatrix(γ, τ)</code></pre><p>Dirichlet surface boundary matrix with uniform timescale. Assumes that the Dirichlet boundary condition is zero.</p><p><strong>Arguments</strong></p><ul><li><code>γ</code>: TMI grid</li><li><code>τ</code>: uniform restoring timescale (years) for all boundary points </li></ul><p><strong>Output</strong></p><ul><li><code>Ldir</code>: circulation matrix in xyz format for boundary points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L272-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.distancematrix-Tuple{Any}" href="#TMI.distancematrix-Tuple{Any}"><code>TMI.distancematrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function distancematrix(γ;surface = true)

Matrix with size of surface points squared

Each entry gives distance in km between surface points
Gives only horizontal distance.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L656-L663">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.download_file-Tuple{String}" href="#TMI.download_file-Tuple{String}"><code>TMI.download_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function download_file(TMIversion::String)

Download NetCDF file for given TMI version</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion::String</code></li></ul><p><strong>Output</strong></p><ul><li><code>TMIfile::String</code>: TMI file name</li></ul><p><strong>Side-effect</strong></p><ul><li>download TMI input file if necessary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L41-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.download_regionfile-Tuple{String}" href="#TMI.download_regionfile-Tuple{String}"><code>TMI.download_regionfile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function download_regionfile(TMIversion::String)</p><p>Return file name of regional masks.</p><p>Also download file from Google Drive, if not already done.</p><p>File name refers to the 2D size of domain. It is the same for modern and LGM configs and only depends on number of points in Nx and Ny directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/regions.jl#L37-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.eastindex-Tuple{Any}" href="#TMI.eastindex-Tuple{Any}"><code>TMI.eastindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function eastindex(I) 
Get the vector index on the northern open boundary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L623-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.effective_endmember-Tuple{Any, Any, Field, Any, Grid}" href="#TMI.effective_endmember-Tuple{Any, Any, Field, Any, Grid}"><code>TMI.effective_endmember</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> function effective_endmember(TMIversion,Alu,field,region,γ)</code></pre><p>Effective (i.e., importance-weighted) endmember tracer value calculated according to Gebbie and Huybers 2011.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L316-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.effective_endmember_sums-Tuple{Any, Field, BoundaryCondition, Grid}" href="#TMI.effective_endmember_sums-Tuple{Any, Field, BoundaryCondition, Grid}"><code>TMI.effective_endmember_sums</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> function effective_endmember_sums(Alu,field::Field,b::BoundaryCondition,γ::Grid)</code></pre><p>Intermediate quantities for computing effective endmembers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L337-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.fieldsatts-Tuple{}" href="#TMI.fieldsatts-Tuple{}"><code>TMI.fieldsatts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>All variable names and attributes. Useful for writing NetCDF files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L384-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.gadjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}" href="#TMI.gadjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.gadjustboundarycondition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function gadjustboundarycondition!(b::BoundaryCondition{T},u::BoundaryCondition{T}) where T &lt;: Real

adjust the (one) boundary condition 
Just copy the variable.
Keep this function so that calling functions can look alike.
Could probably combine with lower function, use Union type</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L434-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.gaussiandistancematrix-Tuple{Any, Any, Any}" href="#TMI.gaussiandistancematrix-Tuple{Any, Any, Any}"><code>TMI.gaussiandistancematrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function gaussiandistancematrix(γ,σ,L)

uses distance matrix plus a lengthscale `L` (km)
and a size of the diagonal `σ`

returns values with inverse gaussian weighting</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L685-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.getboundarycondition-Tuple{Field, Integer, Integer}" href="#TMI.getboundarycondition-Tuple{Field, Integer, Integer}"><code>TMI.getboundarycondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function getboundarycondition(field::Field,dim,dimval)::BoundaryCondition</code></pre><p>Get boundary condition by extracting from Field (i.e., 3D tracer)</p><p><strong>Arguments</strong></p><ul><li><code>field::Field</code>: 3D tracer field with metadata and grid</li><li><code>dim</code>: dimension number (1,2,3) that the boundary plane has constant value</li><li><code>dimval</code>: index number in dimension <code>dim</code> that defines boundary plane</li></ul><p><strong>Output</strong></p><ul><li><code>b::BoundaryCondition</code>: boundary condition on a plane with metadata and grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L242-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.getboundarycondition-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{Field{T, R, N, F} where F&lt;:AbstractArray{T, N}, Integer, Integer, Grid}} where {T&lt;:Real, R&lt;:Real, N}" href="#TMI.getboundarycondition-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{Field{T, R, N, F} where F&lt;:AbstractArray{T, N}, Integer, Integer, Grid}} where {T&lt;:Real, R&lt;:Real, N}"><code>TMI.getboundarycondition</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get boundary condition by extracting from N-dimensional tracer and returning (N-1)-dimensional array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L216-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.gobserve-Union{Tuple{T}, Tuple{Vector{T}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real" href="#TMI.gobserve-Union{Tuple{T}, Tuple{Vector{T}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.gobserve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function gobserve(gy::Vector{T},c::Field{T},wis,γ) where T &lt;: Real

ADJOINT Take a observation at location given by weights wis
Arguments not symmetric with `observe` due to splat operator</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1461-L1466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.grid2nc-Tuple{Any, Any}" href="#TMI.grid2nc-Tuple{Any, Any}"><code>TMI.grid2nc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Put grid properties (Cartesian index) into NetCDF file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L577-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.griddicts-Tuple{Any}" href="#TMI.griddicts-Tuple{Any}"><code>TMI.griddicts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Save grid dictionaries of attributes for writing to NetCDF file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L364-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.gridsize-Tuple{Any}" href="#TMI.gridsize-Tuple{Any}"><code>TMI.gridsize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function gridsize(TMIversion)</p><p>Parse the TMIversion string for the grid size</p><p>Will break if the prefix contains underscores or &#39;x&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}} where T&lt;:Real" href="#TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>TMI.gsetboundarycondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function gsetboundarycondition(gd::Field{T},b::BoundaryCondition{T}) where T&lt;: Real

ADJOINT: apply boundary condition to the equation constraints</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>::Field, equation constraints (i.e., right hand side)</li><li><code>b</code>::BoundaryCondition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L340-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, NamedTuple}} where T&lt;:Real" href="#TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, NamedTuple}} where T&lt;:Real"><code>TMI.gsetboundarycondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function gsetboundarycondition(gd::Field{T},b::BoundaryCondition{T}) where T&lt;: Real

ADJOINT: apply boundary condition to the equation constraints</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>::Field, equation constraints (i.e., right hand side)</li><li><code>b</code>::BoundaryCondition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L376-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.gsetsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real" href="#TMI.gsetsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.gsetsource!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function gsetsource!(gq::Field{T},gd::Field{T},r=1.0)

Adjoint to `setsource!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1253-L1257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.gsteadyinversion-Tuple{Field, Any, Union{NamedTuple, BoundaryCondition}, Grid}" href="#TMI.gsteadyinversion-Tuple{Field, Any, Union{NamedTuple, BoundaryCondition}, Grid}"><code>TMI.gsteadyinversion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function gsteadyinversion(gc,Alu,b;q=nothing,r=1.0)

ADJOINT invert for a steady-state tracer distribution</code></pre><p><strong>Arguments</strong></p><ul><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>b</code>: BoundaryCondition</li><li><code>γ</code>::Grid</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>q</code>: interior sources/sinks of phosphate</li><li><code>r</code>: stochiometric ratio of tracer:phosphate</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>::Field, steady-state tracer distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1831-L1846">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.horizontaldistance-Tuple{Any, Grid}" href="#TMI.horizontaldistance-Tuple{Any, Grid}"><code>TMI.horizontaldistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function horizontaldistance(loc,γ)</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: 3-tuple of lon,lat,depth location</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>hordist</code>: horizontal distance to nearest tracer grid points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L802-L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.interiormask-NTuple{5, Any}" href="#TMI.interiormask-NTuple{5, Any}"><code>TMI.interiormask</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function interiormask(A,wet,nx,ny,nz)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/grid.jl#L190-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.interpindex-Tuple{Any, Any}" href="#TMI.interpindex-Tuple{Any, Any}"><code>TMI.interpindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function interpindex(loc,γ)     Weights for linear interpolation.     The derivative of linear interpolation is needed in sensitivity studies.     ReverseDiff.jl could find this quantity automatically.     Instead we dig into the Interpolations.jl package to find the weights that are effectively the partial derivatives of the function.</p><p><strong>Arguments</strong></p><ul><li><code>c</code>: a temporary tracer field, would be nice to make it unnecessary</li><li><code>loc</code>: (lon,lat,depth) tuple of a location of interest</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>δ</code>: weights on a 3D tracer field grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L828-L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.interpweights-Tuple{Any, Any}" href="#TMI.interpweights-Tuple{Any, Any}"><code>TMI.interpweights</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function interpweights(loc,γ)     Weights for linear interpolation.     The derivative of linear interpolation is needed in sensitivity studies.     ReverseDiff.jl could find this quantity automatically.     Instead we dig into the Interpolations.jl package to find the weights that are effectively the partial derivatives of the function.</p><p><strong>Arguments</strong></p><ul><li><code>loc</code>: (lon,lat,depth) tuple of a location of interest</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>δ</code>: weights on a 3D tracer field grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L886-L897">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.latindex-Tuple{Any}" href="#TMI.latindex-Tuple{Any}"><code>TMI.latindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function latindex(I) 
Get the j-index (latitude index) from the Cartesian index</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L583-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.linearindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N" href="#TMI.linearindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N"><code>TMI.linearindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function linearindex(wet)
Read and assemble the grid coordinates.</code></pre><p><strong>Arguments</strong></p><ul><li><code>wet</code>: 3D mask for wet points</li></ul><p><strong>Output</strong></p><ul><li><code>R</code>: array of linear indices, but not a LinearIndices type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/grid.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.local_watermass_matrix-Tuple{NamedTuple, Union{NamedTuple, Vector}, CartesianIndex, Field}" href="#TMI.local_watermass_matrix-Tuple{NamedTuple, Union{NamedTuple, Vector}, CartesianIndex, Field}"><code>TMI.local_watermass_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function <code>local_watermass_matrix(c::NamedTuple,     m::NamedTuple,     I::CartesianIndex,     neighbors::Field)</code> Find local water-mass matrix with singularity checker (<code>true</code> if one neighbor only has a single connection to the rest of the ocean)</p><p><strong>Arguments</strong></p><ul><li><code>c::NamedTuple</code>: input tracers</li><li><code>m::NamedTuple</code>: mass fractions for grid stencil</li><li><code>I::CartesianIndex</code>: local &quot;location&quot;</li><li><code>neighbors::Field</code>: integer number of neighbors</li></ul><p><strong>Output</strong></p><ul><li><code>A::Matrix</code>: local water-mass matrix</li><li><code>single_connection::Bool</code>: true if flagged for singularity warning</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/mass_fractions.jl#L465-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.lonindex-Tuple{Any}" href="#TMI.lonindex-Tuple{Any}"><code>TMI.lonindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function lonindex(I) 
Get the i-index (lon index) from the Cartesian index</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L572-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.matfields2nc_orig-Tuple{Any, Any}" href="#TMI.matfields2nc_orig-Tuple{Any, Any}"><code>TMI.matfields2nc_orig</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read 3D fields from mat file and save to NetCDF file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/deprecated.jl#L133-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.meanage-Tuple{Any, Any, Any}" href="#TMI.meanage-Tuple{Any, Any, Any}"><code>TMI.meanage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function meanage(TMIversion,Alu,γ)
Mean or ideal age</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>a</code>: mean age [yr]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L232-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.mixedlayermask-Tuple{Any, Grid}" href="#TMI.mixedlayermask-Tuple{Any, Grid}"><code>TMI.mixedlayermask</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function mixedlayermask(A,wet,nx,ny,nz)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/grid.jl#L210-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.mixedlayermatrix-Tuple{Any, Any, Any}" href="#TMI.mixedlayermatrix-Tuple{Any, Any, Any}"><code>TMI.mixedlayermatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> function mixedlayermatrix(A, γ, τ)</code></pre><p>Read and assemble the circulation matrix from the efficient storage of A and F₀ variables. </p><p><strong>Arguments</strong></p><ul><li><code>A</code>: TMI water-mass matrix</li><li><code>γ</code>: TMI grid</li><li><code>τ</code>: uniform residence timescale (years) for all mixed layer points </li></ul><p><strong>Output</strong></p><ul><li><code>Lmix</code>: circulation matrix in xyz format for mixed layer points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L248-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.ncurl-Tuple{Any}" href="#TMI.ncurl-Tuple{Any}"><code>TMI.ncurl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function ncurl(TMIversion)
placeholder function to give location (URL) of NetCDF Google Drive input
in the future, consider a struct or Dict that describes all TMI versions.</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li></ul><p><strong>Output</strong></p><ul><li><code>url</code>: location (URL) for download</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L297-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.nearestneighbor" href="#TMI.nearestneighbor"><code>TMI.nearestneighbor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function nearestneighbor(loc,γ)
return the Cartesian index and linear index 
of the nearest N neighbors</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: 3-tuple of lon,lat,depth location</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>Inn</code>: Cartesian indices of nearest neighbor</li></ul><p>#- <code>Rnn</code>: linear indices of nearest neighbor, Removed from code</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L762-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.nearestneighbormask" href="#TMI.nearestneighbormask"><code>TMI.nearestneighbormask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function nearestneighbormask
Make a 3D tracer field that is 1 at location 
of nearest neighbor, 0 elsewhere</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: location in a 3-tuple (lon,lat,depth)</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>δ</code>: nearest neighbor mask 3D field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L740-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.neighbor_indices" href="#TMI.neighbor_indices"><code>TMI.neighbor_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function <code>neighbor_indices(n::Integer)</code></p><p>Direction (step) of neighbors away from a central point. Choose n = 6 (default) or n=26. </p><p><strong>Argument</strong></p><ul><li><code>n=6</code>: max number of neighbors</li></ul><p><strong>Output</strong></p><ul><li><code>In::Vector{CartesianIndex}</code>: indices of neighbors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/mass_fractions.jl#L160-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.neighbors-Union{Tuple{Grid{R, N}}, Tuple{N}, Tuple{R}} where {R, N}" href="#TMI.neighbors-Union{Tuple{Grid{R, N}}, Tuple{N}, Tuple{R}} where {R, N}"><code>TMI.neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function <code>neighbors(γ::Grid;     longname = &quot;number of neighbors&quot;)</code></p><p>How many neighbors does each grid cell have? Conceptually, it only depends on the grid, but this algorithm is slower than the one that takes mass fractions as input.</p><p><strong>Arguments</strong></p><ul><li><code>γ::TMI.Grid</code></li></ul><p><strong>Output</strong></p><ul><li><code>n::Field</code>: integer number of neighbors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/mass_fractions.jl#L272-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.neighbors-Union{Tuple{N}, Tuple{R}, Tuple{Union{NamedTuple, Vector}, Grid{R, N}}} where {R, N}" href="#TMI.neighbors-Union{Tuple{N}, Tuple{R}, Tuple{Union{NamedTuple, Vector}, Grid{R, N}}} where {R, N}"><code>TMI.neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function <code>neighbors(m::NamedTuple,γ::Grid)</code></p><p>How many neighbors does each grid cell have?</p><p><strong>Arguments</strong></p><ul><li><code>m::NamedTuple</code>: input mass fractions to obtain their stencil (opportunity to simplify)</li><li><code>γ::TMI.Grid</code></li></ul><p><strong>Output</strong></p><ul><li><code>n::Field</code>: integer number of neighbors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/mass_fractions.jl#L238-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.northindex-Tuple{Any}" href="#TMI.northindex-Tuple{Any}"><code>TMI.northindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function northindex(I) 
Get the vector index on the northern open boundary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L611-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}}, 1}, Grid}} where T&lt;:Real" href="#TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}}, 1}, Grid}} where T&lt;:Real"><code>TMI.observe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function observe
Take a observation at location given by weights wis</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1423-L1426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{T, T, T}, 1}, Grid}} where T&lt;:Real" href="#TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{T, T, T}, 1}, Grid}} where T&lt;:Real"><code>TMI.observe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function observe(c,loc,γ)

Extend the TMI.observe method to use locations rather than weighted interpolations.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1445-L1449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.optim2nc-Tuple{Any}" href="#TMI.optim2nc-Tuple{Any}"><code>TMI.optim2nc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Save optimization parameters to NetCDF file)</p><p>Future considerations: split into 2 functions</p><ol><li>read from mat</li><li>save to nc</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L462-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.preformedcarbon13-Tuple{Any, Any, Any}" href="#TMI.preformedcarbon13-Tuple{Any, Any, Any}"><code>TMI.preformedcarbon13</code></a> — <span class="docstring-category">Method</span></header><section><div><p>preformedcarbon13(TMIversion,Alu,γ) = preformednutrient(&quot;δ¹³C&quot;,TMIversion,Alu,γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L227-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.preformednitrate-Tuple{Any, Any, Any}" href="#TMI.preformednitrate-Tuple{Any, Any, Any}"><code>TMI.preformednitrate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>preformednitrate(TMIversion,Alu,γ) = preformednutrient(&quot;NO₃&quot;,TMIversion,Alu,γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L217-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.preformednutrient-Tuple{Union{String, Symbol}, Any, Any, Any}" href="#TMI.preformednutrient-Tuple{Union{String, Symbol}, Any, Any, Any}"><code>TMI.preformednutrient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function preformednutrient(tracer::Union{String,Symbol},TMIversion,Alu,γ)

Preformed (i.e., NO accumulation or remineralization) nutrient</code></pre><p><strong>Arguments</strong></p><ul><li><code>tracer::Union{Symbol,String}</code>: tracer name</li><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>c★</code>: preformed tracer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L187-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.preformedoxygen-Tuple{Any, Any, Any}" href="#TMI.preformedoxygen-Tuple{Any, Any, Any}"><code>TMI.preformedoxygen</code></a> — <span class="docstring-category">Method</span></header><section><div><p>preformedoxygen(TMIversion,Alu,γ) = preformednutrient(&quot;O₂&quot;,TMIversion,Alu,γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L222-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.preformedphosphate-Tuple{Any, Any, Any}" href="#TMI.preformedphosphate-Tuple{Any, Any, Any}"><code>TMI.preformedphosphate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>preformedphosphate(TMIversion,Alu,γ) = preformednutrient(&quot;PO₄&quot;,TMIversion,Alu,γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L212-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.readfield-Union{Tuple{N}, Tuple{A}, Tuple{Any, Any, Grid{A, N}}} where {A, N}" href="#TMI.readfield-Union{Tuple{N}, Tuple{A}, Tuple{Any, Any, Grid{A, N}}} where {A, N}"><code>TMI.readfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function readfield(file,tracername,γ)
Read a tracer field from NetCDF but return it 
as a Field.

Use NCDatasets so that Unicode is correct</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li><li><code>tracername</code>: name of tracer</li><li><code>γ::Grid</code>, TMI grid specification</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>::Field</li></ul><hr/><pre><code class="nohighlight hljs">MATLAB version
function readfield(matfile,mattracername,γ::Grid,Izyx) # for MATLAB

read MATLAB field and transfer zyx format to xyz</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/field.jl#L89-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.readtracer-Tuple{Any, Any}" href="#TMI.readtracer-Tuple{Any, Any}"><code>TMI.readtracer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function readtracer(file,tracername)
Read a tracer field from NetCDF.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li><li><code>tracername</code>: name of tracer</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>: 3D tracer field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/deprecated.jl#L209-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.regeneratednutrient-NTuple{4, Any}" href="#TMI.regeneratednutrient-NTuple{4, Any}"><code>TMI.regeneratednutrient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function regeneratednutrient(TMIversion,Alu,γ)

Regenerated (i.e., accumulated, remineralized) nutrient</code></pre><p><strong>Arguments</strong></p><ul><li><code>tracer::Union{String,Symbol}</code>: tracer name</li><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>γ</code>: TMI grid</li><li><code>r</code>: optional stoichiometric ratio relative to PO₄</li></ul><p><strong>Output</strong></p><ul><li><code>PO₄ᴿ</code>: regenerated phosphate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L147-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.regions_mat2nc-Tuple{Any, Any}" href="#TMI.regions_mat2nc-Tuple{Any, Any}"><code>TMI.regions_mat2nc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function regions2nc(TMIversion,γ)</p><p>Read vectors from mat file, translate to 3D, and save surface field to NetCDF file.</p><p>Consider deprecating this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/regions.jl#L111-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.regionurl-Tuple{Any}" href="#TMI.regionurl-Tuple{Any}"><code>TMI.regionurl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function regionurl(TMIversion)
placeholder function to give location (URL) of NetCDF Google Drive input
in the future, consider a struct or Dict that describes all TMI versions.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: name of file to look for on Google Drive</li></ul><p><strong>Output</strong></p><ul><li><code>regionurl</code>: location (URL) for download of regional mask file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/regions.jl#L66-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.section-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real" href="#TMI.section-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.section</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function section
View latitude-depth slice of field</code></pre><p><strong>Arguments</strong></p><ul><li><code>c::Field</code>, 3D tracer field plus meta data</li><li><code>lon</code>: longitude of section</li></ul><p><strong>Output</strong></p><ul><li><code>csection</code>: 2d slice of field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/field.jl#L65-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.setboundarycondition!-Tuple{Field, BoundaryCondition}" href="#TMI.setboundarycondition!-Tuple{Field, BoundaryCondition}"><code>TMI.setboundarycondition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function setboundarycondition!(d::Field,b::BoundaryCondition)
apply boundary condition to the equation constraints</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>::Field, equation constraints (i.e., right hand side)</li><li><code>b</code>::BoundaryCondition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L320-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.setboundarycondition!-Tuple{Field, NamedTuple}" href="#TMI.setboundarycondition!-Tuple{Field, NamedTuple}"><code>TMI.setboundarycondition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function setboundarycondition!(d::Field{T},b::NamedTuple{&lt;:Any, NTuple{N,BoundaryCondition{T}}}) where {N, T &lt;: Real}

set all boundary conditions in a Named Tuple</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L365-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.setsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real" href="#TMI.setsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.setsource!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function setsource!(d::Field,q::Field,r::Number)
apply interior source q to the equation constraints d</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>::Field, equation constraints (i.e., right hand side)</li><li><code>q</code>::Field, interior source</li><li><code>r</code>::Number, default = 1.0, stoichiometric ratio</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1238-L1246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.shiftloc-Tuple{Any, Any}" href="#TMI.shiftloc-Tuple{Any, Any}"><code>TMI.shiftloc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function  shiftloc(loc)</p><pre><code class="nohighlight hljs">sometimes loc longitudes are outside of grid due to different conventions
assumption: 360° shift is enough to get back on grid</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L860-L865">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.southindex-Tuple{Any}" href="#TMI.southindex-Tuple{Any}"><code>TMI.southindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function southindex(I) 
Get the vector-index on the southern open boundary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L605-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.sparsedatamap_optim-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, Any, Vector, Any, Any, Grid}" href="#TMI.sparsedatamap_optim-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, Any, Vector, Any, Any, Grid}"><code>TMI.sparsedatamap_optim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sparsedatamap(u₀::Vector{T},Alu,b::BoundaryCondition{T},u::BoundaryCondition{T},y::Vector{T},W⁻,wis,locs,Q⁻,γ::Grid;iterations=10) where T &lt;: Real

 Find the distribution of a tracer given:
 (a) the pathways described by A or its LU decomposition Alu,
 (b) first-guess boundary conditions and interior sources given by d₀,
 (c) perturbations to the surface boundary condition u₀
that best fits observations, y,
according to the cost function,
J = (ỹ - y)ᵀ W⁻¹ (ỹ - y)
subject to Aỹ = d₀ + Γ u₀.                 
W⁻ is a (sparse) weighting matrix.
See Supplementary Section 2, Gebbie &amp; Huybers 2011.</code></pre><p><strong>Arguments</strong></p><ul><li><code>u₀</code>:</li><li><code>Alu</code>:</li><li><code>b</code>: first guess of boundary conditions and interior sources</li><li><code>y</code>: observations on 3D grid</li><li><code>W⁻</code>: weighting matrix best chosen as inverse error covariance matrix</li><li><code>fg!</code>: compute cost function and gradient in place</li><li><code>γ</code>: grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L431-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.steadyclimatology_optim-Tuple{Any, Any, Any}" href="#TMI.steadyclimatology_optim-Tuple{Any, Any, Any}"><code>TMI.steadyclimatology_optim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function steadyclimatology_optim(u₀,fg!,iterations)      Find the distribution of a tracer given:      (a) the pathways described by A or its LU decomposition Alu,      (b) first-guess boundary conditions and interior sources given by d₀,      (c) perturbations to the surface boundary condition u₀     that best fits observations, y,     according to the cost function,     J = (ỹ - y)ᵀ W⁻¹ (ỹ - y)     subject to Aỹ = d₀ + Γ u₀.                      W⁻ is a (sparse) weighting matrix.     See Supplementary Section 2, Gebbie &amp; Huybers 2011.</p><p><strong>Arguments</strong></p><ul><li><code>u₀</code>:</li><li><code>fg!</code>: compute cost function and gradient in place</li><li><code>iterations</code>: number of optimization iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L389-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.steadyinversion-Union{Tuple{T}, Tuple{Any, BoundaryCondition, Grid{T}}} where T&lt;:Real" href="#TMI.steadyinversion-Union{Tuple{T}, Tuple{Any, BoundaryCondition, Grid{T}}} where T&lt;:Real"><code>TMI.steadyinversion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function steadyinversion(Alu,b;q=nothing,r=1.0)
invert for a steady-state tracer distribution</code></pre><p><strong>Arguments</strong></p><ul><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>b</code>: boundary condition, assumed to be surface boundary condition</li><li><code>γ</code>::Grid</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>q</code>: interior sources/sinks of phosphate</li><li><code>r</code>: stochiometric ratio of tracer:phosphate</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>::Field, steady-state tracer distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1800-L1813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.step_cartesian-Union{Tuple{N}, Tuple{R}, Tuple{CartesianIndex{N}, CartesianIndex{N}, Grid{R, N}}} where {R, N}" href="#TMI.step_cartesian-Union{Tuple{N}, Tuple{R}, Tuple{CartesianIndex{N}, CartesianIndex{N}, Grid{R, N}}} where {R, N}"><code>TMI.step_cartesian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function <code>step_cartesian(I, Δ, γ)</code></p><p><strong>Arguments</strong></p><ul><li><code>I::CartesianIndex</code>: starting point</li><li><code>Δ::CartesianIndex</code>: step</li><li><code>γ::Grid</code>: TMI-defined grid</li></ul><p><strong>Output</strong></p><ul><li><code>Istep::CartesianIndex</code>: new location</li><li><code>inbounds::Bool</code>: inside the domain bounds?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/mass_fractions.jl#L98-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{T}, Any}} where T&lt;:Real" href="#TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function surfacecontrol2field!(c,u,γ)
Add surface control vector to existing 3D field</code></pre><p><strong>Arguments</strong></p><ul><li><code>c</code>:: state field, 3d tracer field with NaN on dry points, modified by function</li><li><code>usfc</code>:: surface control vector</li><li><code>wet</code>::BitArray mask of ocean points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/deprecated.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Any}} where T&lt;:Real" href="#TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function surfacecontrol2field!(c,u,γ)
Add surface control vector to tracer vector</code></pre><p><strong>Arguments</strong></p><ul><li><code>c</code>:: state field, 3d tracer field with NaN on dry points, modified by function</li><li><code>u</code>:: surface control vector</li><li><code>wet</code>::BitArray mask of ocean points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/deprecated.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.surfacecontrol2field-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real" href="#TMI.surfacecontrol2field-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function surfacecontrol2field(usfc,γ.wet)
turn surface control vector into 3D field with zeroes below surface</code></pre><p><strong>Arguments</strong></p><ul><li><code>usfc</code>:: surface control vector</li><li><code>wet</code>::BitArray mask of ocean points</li></ul><p><strong>Output</strong></p><ul><li><code>tracer3D</code>:: 3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/deprecated.jl#L112-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.surfaceindex-Tuple{Any}" href="#TMI.surfaceindex-Tuple{Any}"><code>TMI.surfaceindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function surfaceindex(I) 
Get the vector-index where depth level == 1 and it is ocean.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L599-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.surfaceorigin-Tuple{Any, Any, Grid}" href="#TMI.surfaceorigin-Tuple{Any, Any, Grid}"><code>TMI.surfaceorigin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function surfaceorigin(TMIversion,loc)
 Find the surface origin of water for some interior box 
 This is equivalent to solving a sensitivity problem:
 The mass fraction at a location `loc` of interest is 
`c[loc] = δᵀ c`, where `δ` samples the location of the global mass-fraction variable, c.
Then the sensitivity of `c[loc]` is: d(c[loc])/d(d) = A⁻ᵀ δ.
The derivative is solved using the constraint: Ac = d.
The sensitivity is exactly the mass fraction originating from each source.      
This problem is mathematically similar to determining how the ocean is filled.</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: location (lon,lat,depth) of location of interest</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>origin</code>: surface map of fraction of source water for a given location, log10 of effective depth, in terms of a BoundaryCondition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L354-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.surfacepatch-Union{Tuple{R}, Tuple{Any, Any, Grid{R, 3}}} where R" href="#TMI.surfacepatch-Union{Tuple{R}, Tuple{Any, Any, Grid{R, 3}}} where R"><code>TMI.surfacepatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function surfacepatch
Make a surface boundary condition
with a rectangular patch</code></pre><p><strong>Arguments</strong></p><ul><li><code>lonbox</code>: longitudes of box edges</li><li><code>latbox</code>: latitudes of box edges</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>d</code>: vector that describes surface patch</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L257-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.surfaceregion-Tuple{String, Union{String, Symbol}, Grid}" href="#TMI.surfaceregion-Tuple{String, Union{String, Symbol}, Grid}"><code>TMI.surfaceregion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> function surfaceregion(TMIversion::String,region::String,γ::Grid)::BoundaryCondition

Read an oceanographically-relevant surface region from NetCDF file. (Also could be read from mat file.)</code></pre><p>Return a BoundaryCondition</p><pre><code class="nohighlight hljs">Version 1: operates on a 2D Float field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/deprecated.jl#L174-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.surfaceregion-Tuple{String, Union{String, Symbol}}" href="#TMI.surfaceregion-Tuple{String, Union{String, Symbol}}"><code>TMI.surfaceregion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> function surfaceregion(TMIversion::String,region::String,γ::Grid)::BoundaryCondition

Read an oceanographically-relevant surface region from NetCDF file. (Also could be read from mat file.)
Return a BoundaryCondition</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/regions.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.synthetic_observations" href="#TMI.synthetic_observations"><code>TMI.synthetic_observations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function synthetic_observations(TMIversion,variable,locs)
Synthetic observations that are a contaminated version of real observations
This version: observations with random (uniform) spatial sampling</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion::String</code>: version of TMI water-mass/circulation model</li><li><code>variable::String</code>: variable name to use as template</li><li><code>N</code>: number of observations</li></ul><p><strong>Output</strong></p><ul><li><code>y</code>: contaminated observations on 3D grid</li><li><code>W⁻</code>: appropriate weighting (inverse covariance) matrix for these observations,</li><li><code>ytrue</code>: uncontaminated observations, 3D field</li><li><code>locs</code>: 3-tuples of locations for observations</li><li><code>wis</code>: weighted indices for interpolation to locs sites</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1367-L1382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.synthetic_observations-Tuple{Any, Any, Any}" href="#TMI.synthetic_observations-Tuple{Any, Any, Any}"><code>TMI.synthetic_observations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function synthetic_observations(TMIversion,variable)
Synthetic observations that are a contaminated version of real observations
This version: gridded observations</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion::String</code>: version of TMI water-mass/circulation model</li><li><code>variable::String</code>: variable name to use as template</li></ul><p><strong>Output</strong></p><ul><li><code>y</code>: contaminated observations on 3D grid</li><li><code>W⁻</code>: appropriate weighting (inverse covariance) matrix for these observations,</li><li><code>θtrue</code>: real observations, 3D field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1328-L1340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.tracerinit-Tuple{Any, Any, Any}" href="#TMI.tracerinit-Tuple{Any, Any, Any}"><code>TMI.tracerinit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function tracerinit(wet,vec,I)
      initialize tracer field on TMI grid
    perhaps better to have a tracer struct and constructor</code></pre><p><strong>Arguments</strong></p><ul><li><code>wet</code>:: BitArray mask of ocean points</li><li><code>vec</code>:: vector of values at wet points</li><li><code>I</code>:: Cartesian Index for vector</li></ul><p><strong>Output</strong></p><ul><li><code>field</code>:: 3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L605-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.trackpathways-NTuple{4, Any}" href="#TMI.trackpathways-NTuple{4, Any}"><code>TMI.trackpathways</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function trackpathways(TMIversion,latbox,lonbox)
Track the pathways of a user-defined water mass.
 Steps: (a) define the water mass by a rectangular surface patch dyed with passive tracer concentration of         (b) propagate the dye with the matrix A, with the result being the fraction of water originating from the surface region.
 See Section 2b of Gebbie &amp; Huybers 2010, esp. eqs. (15)-(17).</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>latbox</code>: min and max latitude of box</li><li><code>lonbox</code>: min and max longitude of box</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>: fraction of water from surface source</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L105-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.unvec!-Union{Tuple{T}, Tuple{Union{BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Vector{T}}} where T&lt;:Real" href="#TMI.unvec!-Union{Tuple{T}, Tuple{Union{BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Vector{T}}} where T&lt;:Real"><code>TMI.unvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function unvec!(u,uvec)

Undo the operations by vec(u)
Needs to update u because attributes of 
u need to be known at runtime.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1305-L1311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.unvec-Tuple{Union{NamedTuple, BoundaryCondition, Field}, Vector}" href="#TMI.unvec-Tuple{Union{NamedTuple, BoundaryCondition, Field}, Vector}"><code>TMI.unvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function unvec(u,uvec)

Replace u with new u
Undo the operations by vec(u)
Needs to update u because attributes of 
u need to be known at runtime.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1291-L1298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.vec2fld-Union{Tuple{T}, Tuple{Vector{T}, Vector{CartesianIndex{3}}}} where T&lt;:Real" href="#TMI.vec2fld-Union{Tuple{T}, Tuple{Vector{T}, Vector{CartesianIndex{3}}}} where T&lt;:Real"><code>TMI.vec2fld</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function vec2fld
Transfer a vector to a 3D field with accounting for ocean bathymetry</code></pre><p><strong>Arguments</strong></p><ul><li><code>vector</code>: field in vector form (no land points)</li><li><code>I</code>: cartesian indices of ocean points</li></ul><p><strong>Output</strong></p><ul><li><code>field</code>: field in 3d form including land points (NaN)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/deprecated.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.volumefilled-Tuple{Any, Any, Any}" href="#TMI.volumefilled-Tuple{Any, Any, Any}"><code>TMI.volumefilled</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function volumefilled(TMIversion)
Find the ocean volume that has originated from each surface box.
 This is equivalent to solving a sensitivity problem:
 The total volume is V = vᵀ c , where v is the volume of each box 
 and c is the fraction of volume from a given source which
 satisfies the equation A c = d.                     
 Next, dV/d(d) = A⁻ᵀ v, and dV/d(d) is exactly the volume originating from each source.

 See Section 3 and Supplementary Section 4, Gebbie &amp; Huybers 2011.</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>volume</code>: log10 of global ocean volume filled by a surface region, exists at surface, therefore given BoundaryCondition type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L270-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.watermassdistribution-NTuple{4, Any}" href="#TMI.watermassdistribution-NTuple{4, Any}"><code>TMI.watermassdistribution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function watermassdistribution(TMIversion,latbox,lonbox)
Track the pathways of a user-defined water mass.
 Steps: (a) define the water mass by an oceanographically-relevant surface patch dyed with passive tracer concentration of one
     (b) propagate the dye with the matrix A, with the result being the fraction of water originating from the surface region.
 See Section 2b of Gebbie &amp; Huybers 2010, esp. eqs. (15)-(17).</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>region</code>: name of pre-defined surface region</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>g</code>: water-mass fraction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L126-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.watermassmatrix-Tuple{Any}" href="#TMI.watermassmatrix-Tuple{Any}"><code>TMI.watermassmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function watermassmatrix(file)
Read and assemble the water-mass matrix.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF or MATLAB file name</li></ul><p><strong>Output</strong></p><ul><li><code>A</code>: water-mass matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/config.jl#L130-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.watermassmatrix-Tuple{Union{NamedTuple, Vector}, Grid}" href="#TMI.watermassmatrix-Tuple{Union{NamedTuple, Vector}, Grid}"><code>TMI.watermassmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>function watermassmatrix(m::Union{NamedTuple,Vector}, γ::Grid)</code></p><p>Produce water-mass matrix from mass fractions and grid.</p><p><strong>Arguments</strong></p><ul><li><code>m::NamedTuple</code>: collection of <code>MassFraction</code>s</li><li><code>γ::TMI.Grid</code></li></ul><p><strong>Output</strong></p><ul><li><code>A</code>: sparse water-mass matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/mass_fractions.jl#L362-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.westindex-Tuple{Any}" href="#TMI.westindex-Tuple{Any}"><code>TMI.westindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function westindex(I) 
Get the vector index on the western open boundary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L617-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.wetlocation-Tuple{Any}" href="#TMI.wetlocation-Tuple{Any}"><code>TMI.wetlocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function wetlocation(γ)
Get (lon,lat,depth) tuples of wet locations.
Allow a location to be wet if at least one out of 8 nearby gridpoints is wet.
Certainly &quot;wet&quot; gridpoints could be defined more strictly.</code></pre><p><strong>Arguments</strong></p><ul><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>loc</code>: lon,lat,depth </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L1913-L1921">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.write-Union{Tuple{T}, Tuple{Any, Union{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}}} where T&lt;:Real" href="#TMI.write-Union{Tuple{T}, Tuple{Any, Union{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}}} where T&lt;:Real"><code>TMI.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function writefield(file,field)

Write a Field to NetCDF.

Use NCDatasets so that Unicode is correct</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li><li><code>field::Field</code>: a TMI.Field struct</li></ul><p><strong>Output</strong></p><ul><li>none</li></ul><p><strong>Side-effect</strong></p><ul><li>write to <code>file</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/TMI.jl#L495-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.write-Union{Tuple{T}, Tuple{R}, Tuple{N}, Tuple{B}, Tuple{Any, BoundaryCondition{T, R, N, B, B1} where B1&lt;:AbstractArray{T, N}}} where {B&lt;:(AbstractMatrix), N&lt;:Integer, R&lt;:Real, T&lt;:Real}" href="#TMI.write-Union{Tuple{T}, Tuple{R}, Tuple{N}, Tuple{B}, Tuple{Any, BoundaryCondition{T, R, N, B, B1} where B1&lt;:AbstractArray{T, N}}} where {B&lt;:(AbstractMatrix), N&lt;:Integer, R&lt;:Real, T&lt;:Real}"><code>TMI.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function write(file,b)

Write a BoundaryCondition to NetCDF.

Use NCDatasets so that Unicode is correct</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li><li><code>b::BoundaryCondition</code>: a TMI.BoundaryCondition struct</li></ul><p><strong>Output</strong></p><ul><li>none</li></ul><p><strong>Side-effect</strong></p><ul><li>write to <code>file</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/boundary_condition.jl#L72-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.Γsfc!" href="#TMI.Γsfc!"><code>TMI.Γsfc!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function Γsfc! 
Γsfc! anonymously calls surfacecontrol2field!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/6d3e5ad80958f0453c88d15466183f9412775b05/src/deprecated.jl#L60-L63">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../utils/">« Utilities</a><a class="docs-footer-nextpage" href="../legacy/">Older functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 18 June 2025 12:58">Wednesday 18 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
