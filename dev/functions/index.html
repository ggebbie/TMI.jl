<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function List · TMI.jl</title><meta name="title" content="Function List · TMI.jl"/><meta property="og:title" content="Function List · TMI.jl"/><meta property="twitter:title" content="Function List · TMI.jl"/><meta name="description" content="Documentation for TMI.jl."/><meta property="og:description" content="Documentation for TMI.jl."/><meta property="twitter:description" content="Documentation for TMI.jl."/><meta property="og:url" content="https://ggebbie.github.io/TMI.jl/functions/"/><meta property="twitter:url" content="https://ggebbie.github.io/TMI.jl/functions/"/><link rel="canonical" href="https://ggebbie.github.io/TMI.jl/functions/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TMI.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Top-level functions</a></li><li><a class="tocitem" href="../config/">Configuration</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../boundaries/">Boundary Conditions</a></li><li><a class="tocitem" href="../plots/">Plots</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li class="is-active"><a class="tocitem" href>Function List</a></li><li><a class="tocitem" href="../legacy/">Older functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function List</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function List</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ggebbie/TMI.jl/blob/main/docs/src/functions.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="TMI"><a class="docs-heading-anchor" href="#TMI">TMI</a><a id="TMI-1"></a><a class="docs-heading-anchor-permalink" href="#TMI" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/ggebbie/TMI.jl">TMI</a>.</p><ul><li><a href="#TMI.BoundaryCondition"><code>TMI.BoundaryCondition</code></a></li><li><a href="#TMI.Field"><code>TMI.Field</code></a></li><li><a href="#TMI.Grid"><code>TMI.Grid</code></a></li><li><a href="#TMI.Grid-Tuple{String}"><code>TMI.Grid</code></a></li><li><a href="#TMI.MassFraction"><code>TMI.MassFraction</code></a></li><li><a href="#TMI.Source"><code>TMI.Source</code></a></li><li><a href="#Base.:\\-Union{Tuple{T}, Tuple{Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>Base.:\</code></a></li><li><a href="#Base.length-Tuple{Union{BoundaryCondition, Field, TMI.Source}}"><code>Base.length</code></a></li><li><a href="#Base.one-Tuple{Type{Field}}"><code>Base.one</code></a></li><li><a href="#Base.one-Union{Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{T}} where T&lt;:Real"><code>Base.one</code></a></li><li><a href="../utils/#Base.ones"><code>Base.ones</code></a></li><li><a href="#Base.ones-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer"><code>Base.ones</code></a></li><li><a href="#Base.ones"><code>Base.ones</code></a></li><li><a href="#Base.propertynames-Tuple{Grid}"><code>Base.propertynames</code></a></li><li><a href="#Base.sum-Tuple{Field}"><code>Base.sum</code></a></li><li><a href="../utils/#Base.vec"><code>Base.vec</code></a></li><li><a href="#Base.vec-Tuple{Field}"><code>Base.vec</code></a></li><li><a href="#Base.zero-Tuple{Field}"><code>Base.zero</code></a></li><li><a href="#Base.zeros-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer"><code>Base.zeros</code></a></li><li><a href="../utils/#Base.zeros"><code>Base.zeros</code></a></li><li><a href="#Base.zeros"><code>Base.zeros</code></a></li><li><a href="#Base.zeros-Union{Tuple{Grid{T}}, Tuple{T}, Tuple{Grid{T}, Any}, Tuple{Grid{T}, Any, Any}, Tuple{Grid{T}, Any, Any, Any}} where T&lt;:Real"><code>Base.zeros</code></a></li><li><a href="#LinearAlgebra.dot-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>LinearAlgebra.dot</code></a></li><li><a href="../utils/#LinearAlgebra.dot"><code>LinearAlgebra.dot</code></a></li><li><a href="#TMI.add!-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Union{BoundaryCondition, Field, TMI.Source}"><code>TMI.add!</code></a></li><li><a href="#TMI.adjustboundarycondition-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.adjustboundarycondition</code></a></li><li><a href="../boundaries/#TMI.adjustboundarycondition!"><code>TMI.adjustboundarycondition!</code></a></li><li><a href="#TMI.adjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.adjustboundarycondition!</code></a></li><li><a href="#TMI.axislabels-Tuple{String}"><code>TMI.axislabels</code></a></li><li><a href="#TMI.boundaryconditionatts-Union{Tuple{N}, Tuple{R}, Tuple{Integer, Integer, Grid{R, N}}} where {R, N}"><code>TMI.boundaryconditionatts</code></a></li><li><a href="#TMI.boundarymask-Tuple{Grid}"><code>TMI.boundarymask</code></a></li><li><a href="#TMI.boundarymask-Tuple{BoundaryCondition, Grid}"><code>TMI.boundarymask</code></a></li><li><a href="#TMI.boundarymatrix-Tuple{Any, Any}"><code>TMI.boundarymatrix</code></a></li><li><a href="../config/#TMI.boundarymatrix"><code>TMI.boundarymatrix</code></a></li><li><a href="../config/#TMI.boundarymatrix2nc"><code>TMI.boundarymatrix2nc</code></a></li><li><a href="#TMI.boundarymatrix2nc-Tuple{Any, Any}"><code>TMI.boundarymatrix2nc</code></a></li><li><a href="#TMI.cartesianindex-Tuple{String}"><code>TMI.cartesianindex</code></a></li><li><a href="../config/#TMI.cartesianindex"><code>TMI.cartesianindex</code></a></li><li><a href="#TMI.cartesianindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N"><code>TMI.cartesianindex</code></a></li><li><a href="#TMI.cellarea-Tuple{Any}"><code>TMI.cellarea</code></a></li><li><a href="../grid/#TMI.cellarea"><code>TMI.cellarea</code></a></li><li><a href="../grid/#TMI.cellvolume"><code>TMI.cellvolume</code></a></li><li><a href="#TMI.cellvolume-Tuple{Any}"><code>TMI.cellvolume</code></a></li><li><a href="#TMI.checkgrid!-Tuple{Any, Any}"><code>TMI.checkgrid!</code></a></li><li><a href="#TMI.circulationmatrix-Tuple{Any, Any, Any}"><code>TMI.circulationmatrix</code></a></li><li><a href="../config/#TMI.circulationmatrix"><code>TMI.circulationmatrix</code></a></li><li><a href="#TMI.circulationmatrix-Tuple{Any, Any}"><code>TMI.circulationmatrix</code></a></li><li><a href="../config/#TMI.circulationmatrix2nc"><code>TMI.circulationmatrix2nc</code></a></li><li><a href="#TMI.circulationmatrix2nc-Tuple{Any, Any, Any}"><code>TMI.circulationmatrix2nc</code></a></li><li><a href="#TMI.config-Tuple{Any}"><code>TMI.config</code></a></li><li><a href="../config/#TMI.config2nc"><code>TMI.config2nc</code></a></li><li><a href="#TMI.config2nc-NTuple{5, Any}"><code>TMI.config2nc</code></a></li><li><a href="#TMI.control2state-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T&lt;:Real"><code>TMI.control2state</code></a></li><li><a href="../legacy/#TMI.control2state"><code>TMI.control2state</code></a></li><li><a href="#TMI.costfunction_gridded_model-Union{Tuple{T}, Tuple{Any, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real"><code>TMI.costfunction_gridded_model</code></a></li><li><a href="#TMI.costfunction_gridded_model!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real"><code>TMI.costfunction_gridded_model!</code></a></li><li><a href="../utils/#TMI.costfunction_gridded_obs"><code>TMI.costfunction_gridded_obs</code></a></li><li><a href="#TMI.costfunction_gridded_obs-Union{Tuple{T}, Tuple{Any, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid{T}}} where T&lt;:Real"><code>TMI.costfunction_gridded_obs</code></a></li><li><a href="../utils/#TMI.costfunction_gridded_obs!"><code>TMI.costfunction_gridded_obs!</code></a></li><li><a href="#TMI.costfunction_gridded_obs!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Union{NamedTuple, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}, Union{NamedTuple, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid{T}}} where T&lt;:Real"><code>TMI.costfunction_gridded_obs!</code></a></li><li><a href="#TMI.costfunction_point_obs-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}"><code>TMI.costfunction_point_obs</code></a></li><li><a href="../utils/#TMI.costfunction_point_obs"><code>TMI.costfunction_point_obs</code></a></li><li><a href="../utils/#TMI.costfunction_point_obs!"><code>TMI.costfunction_point_obs!</code></a></li><li><a href="#TMI.costfunction_point_obs!-Tuple{Any, Union{Nothing, Vector}, Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}"><code>TMI.costfunction_point_obs!</code></a></li><li><a href="../grid/#TMI.depthindex"><code>TMI.depthindex</code></a></li><li><a href="#TMI.depthindex-Tuple{Any}"><code>TMI.depthindex</code></a></li><li><a href="#TMI.dirichletmatrix-Tuple{Grid, Any}"><code>TMI.dirichletmatrix</code></a></li><li><a href="#TMI.distancematrix-Tuple{Any}"><code>TMI.distancematrix</code></a></li><li><a href="#TMI.download_file-Tuple{String}"><code>TMI.download_file</code></a></li><li><a href="#TMI.download_regionfile-Tuple{String}"><code>TMI.download_regionfile</code></a></li><li><a href="#TMI.eastindex-Tuple{Any}"><code>TMI.eastindex</code></a></li><li><a href="../grid/#TMI.eastindex"><code>TMI.eastindex</code></a></li><li><a href="#TMI.effective_endmember-Tuple{Any, Any, Field, Any, Grid}"><code>TMI.effective_endmember</code></a></li><li><a href="#TMI.effective_endmember_sums-Tuple{Any, Field, BoundaryCondition, Grid}"><code>TMI.effective_endmember_sums</code></a></li><li><a href="../config/#TMI.fieldsatts"><code>TMI.fieldsatts</code></a></li><li><a href="#TMI.fieldsatts-Tuple{}"><code>TMI.fieldsatts</code></a></li><li><a href="#TMI.gadjustboundarycondition-Union{Tuple{T}, Tuple{BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>TMI.gadjustboundarycondition</code></a></li><li><a href="../boundaries/#TMI.gadjustboundarycondition"><code>TMI.gadjustboundarycondition</code></a></li><li><a href="../boundaries/#TMI.gadjustboundarycondition!"><code>TMI.gadjustboundarycondition!</code></a></li><li><a href="#TMI.gadjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.gadjustboundarycondition!</code></a></li><li><a href="#TMI.gaussiandistancematrix-Tuple{Any, Any, Any}"><code>TMI.gaussiandistancematrix</code></a></li><li><a href="#TMI.getboundarycondition-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{Field{T, R, N, F} where F&lt;:AbstractArray{T, N}, Integer, Integer, Grid}} where {T&lt;:Real, R&lt;:Real, N}"><code>TMI.getboundarycondition</code></a></li><li><a href="#TMI.getboundarycondition-Tuple{Field, Integer, Integer}"><code>TMI.getboundarycondition</code></a></li><li><a href="../boundaries/#TMI.getboundarycondition"><code>TMI.getboundarycondition</code></a></li><li><a href="#TMI.geteastboundary-Tuple{Field}"><code>TMI.geteastboundary</code></a></li><li><a href="../boundaries/#TMI.geteastboundary"><code>TMI.geteastboundary</code></a></li><li><a href="../boundaries/#TMI.getnorthboundary"><code>TMI.getnorthboundary</code></a></li><li><a href="#TMI.getnorthboundary-Tuple{Field}"><code>TMI.getnorthboundary</code></a></li><li><a href="../boundaries/#TMI.getsouthboundary"><code>TMI.getsouthboundary</code></a></li><li><a href="#TMI.getsouthboundary-Tuple{Field}"><code>TMI.getsouthboundary</code></a></li><li><a href="../boundaries/#TMI.getsurfaceboundary"><code>TMI.getsurfaceboundary</code></a></li><li><a href="#TMI.getsurfaceboundary-Tuple{Field}"><code>TMI.getsurfaceboundary</code></a></li><li><a href="#TMI.getwestboundary-Tuple{Field}"><code>TMI.getwestboundary</code></a></li><li><a href="../boundaries/#TMI.getwestboundary"><code>TMI.getwestboundary</code></a></li><li><a href="#TMI.gobserve-Union{Tuple{T}, Tuple{Vector{T}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.gobserve</code></a></li><li><a href="../utils/#TMI.gobserve"><code>TMI.gobserve</code></a></li><li><a href="#TMI.grid2nc-Tuple{Any, Any}"><code>TMI.grid2nc</code></a></li><li><a href="../config/#TMI.grid2nc"><code>TMI.grid2nc</code></a></li><li><a href="../config/#TMI.griddicts"><code>TMI.griddicts</code></a></li><li><a href="#TMI.griddicts-Tuple{Any}"><code>TMI.griddicts</code></a></li><li><a href="#TMI.gridsize-Tuple{Any}"><code>TMI.gridsize</code></a></li><li><a href="../boundaries/#TMI.gsetboundarycondition"><code>TMI.gsetboundarycondition</code></a></li><li><a href="#TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, NamedTuple}} where T&lt;:Real"><code>TMI.gsetboundarycondition</code></a></li><li><a href="#TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>TMI.gsetboundarycondition</code></a></li><li><a href="#TMI.gsetsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.gsetsource!</code></a></li><li><a href="../utils/#TMI.gsteadyinversion"><code>TMI.gsteadyinversion</code></a></li><li><a href="#TMI.gsteadyinversion-Tuple{Field, Any, Union{NamedTuple, BoundaryCondition}, Grid}"><code>TMI.gsteadyinversion</code></a></li><li><a href="#TMI.horizontaldistance-Tuple{Any, Grid}"><code>TMI.horizontaldistance</code></a></li><li><a href="../grid/#TMI.horizontaldistance"><code>TMI.horizontaldistance</code></a></li><li><a href="#TMI.interiormask-NTuple{5, Any}"><code>TMI.interiormask</code></a></li><li><a href="../grid/#TMI.interpindex"><code>TMI.interpindex</code></a></li><li><a href="#TMI.interpindex-Tuple{Any, Any}"><code>TMI.interpindex</code></a></li><li><a href="../grid/#TMI.interpweights"><code>TMI.interpweights</code></a></li><li><a href="#TMI.interpweights-Tuple{Any, Any}"><code>TMI.interpweights</code></a></li><li><a href="../utils/#TMI.iswet"><code>TMI.iswet</code></a></li><li><a href="#TMI.iswet-Tuple{Any, Any, Any}"><code>TMI.iswet</code></a></li><li><a href="../grid/#TMI.latindex"><code>TMI.latindex</code></a></li><li><a href="#TMI.latindex-Tuple{Any}"><code>TMI.latindex</code></a></li><li><a href="../grid/#TMI.linearindex"><code>TMI.linearindex</code></a></li><li><a href="#TMI.linearindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N"><code>TMI.linearindex</code></a></li><li><a href="#TMI.local_watermass_matrix-Tuple{NamedTuple, Union{NamedTuple, Vector}, CartesianIndex, Field}"><code>TMI.local_watermass_matrix</code></a></li><li><a href="../utils/#TMI.location_obs"><code>TMI.location_obs</code></a></li><li><a href="#TMI.location_obs-Tuple{Any, Any, Any}"><code>TMI.location_obs</code></a></li><li><a href="#TMI.lonindex-Tuple{Any}"><code>TMI.lonindex</code></a></li><li><a href="../grid/#TMI.lonindex"><code>TMI.lonindex</code></a></li><li><a href="#TMI.matfields2nc_orig-Tuple{Any, Any}"><code>TMI.matfields2nc_orig</code></a></li><li><a href="#TMI.matrix_modern2glacial-Tuple{Any, Any, Any}"><code>TMI.matrix_modern2glacial</code></a></li><li><a href="../#TMI.meanage"><code>TMI.meanage</code></a></li><li><a href="#TMI.meanage-Tuple{Any, Any, Any}"><code>TMI.meanage</code></a></li><li><a href="#TMI.mixedlayermask-Tuple{Any, Grid}"><code>TMI.mixedlayermask</code></a></li><li><a href="#TMI.mixedlayermatrix-Tuple{Any, Any, Any}"><code>TMI.mixedlayermatrix</code></a></li><li><a href="../config/#TMI.ncurl"><code>TMI.ncurl</code></a></li><li><a href="#TMI.ncurl-Tuple{Any}"><code>TMI.ncurl</code></a></li><li><a href="#TMI.nearestneighbor"><code>TMI.nearestneighbor</code></a></li><li><a href="../utils/#TMI.nearestneighbor"><code>TMI.nearestneighbor</code></a></li><li><a href="../utils/#TMI.nearestneighbormask"><code>TMI.nearestneighbormask</code></a></li><li><a href="#TMI.nearestneighbormask"><code>TMI.nearestneighbormask</code></a></li><li><a href="#TMI.neighbor_indices"><code>TMI.neighbor_indices</code></a></li><li><a href="#TMI.neighbors-Union{Tuple{N}, Tuple{R}, Tuple{Union{NamedTuple, Vector}, Grid{R, N}}} where {R, N}"><code>TMI.neighbors</code></a></li><li><a href="#TMI.neighbors-Union{Tuple{Grid{R, N}}, Tuple{N}, Tuple{R}} where {R, N}"><code>TMI.neighbors</code></a></li><li><a href="#TMI.northindex-Tuple{Any}"><code>TMI.northindex</code></a></li><li><a href="../grid/#TMI.northindex"><code>TMI.northindex</code></a></li><li><a href="#TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}}, 1}, Grid}} where T&lt;:Real"><code>TMI.observe</code></a></li><li><a href="#TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{T, T, T}, 1}, Grid}} where T&lt;:Real"><code>TMI.observe</code></a></li><li><a href="../utils/#TMI.observe"><code>TMI.observe</code></a></li><li><a href="#TMI.oneeastboundary"><code>TMI.oneeastboundary</code></a></li><li><a href="#TMI.onenorthboundary"><code>TMI.onenorthboundary</code></a></li><li><a href="#TMI.onesouthboundary"><code>TMI.onesouthboundary</code></a></li><li><a href="#TMI.onesurfaceboundary"><code>TMI.onesurfaceboundary</code></a></li><li><a href="../boundaries/#TMI.onesurfaceboundary"><code>TMI.onesurfaceboundary</code></a></li><li><a href="#TMI.onewestboundary"><code>TMI.onewestboundary</code></a></li><li><a href="#TMI.optim2nc-Tuple{Any}"><code>TMI.optim2nc</code></a></li><li><a href="../config/#TMI.optim2nc"><code>TMI.optim2nc</code></a></li><li><a href="#TMI.preformedcarbon13-Tuple{Any, Any, Any}"><code>TMI.preformedcarbon13</code></a></li><li><a href="#TMI.preformednitrate-Tuple{Any, Any, Any}"><code>TMI.preformednitrate</code></a></li><li><a href="#TMI.preformednutrient-Tuple{Union{String, Symbol}, Any, Any, Any}"><code>TMI.preformednutrient</code></a></li><li><a href="#TMI.preformedoxygen-Tuple{Any, Any, Any}"><code>TMI.preformedoxygen</code></a></li><li><a href="#TMI.preformedphosphate-Tuple{Any, Any, Any}"><code>TMI.preformedphosphate</code></a></li><li><a href="#TMI.readfield-Union{Tuple{N}, Tuple{A}, Tuple{Any, Any, Grid{A, N}}} where {A, N}"><code>TMI.readfield</code></a></li><li><a href="#TMI.readtracer-Tuple{Any, Any}"><code>TMI.readtracer</code></a></li><li><a href="#TMI.regeneratednutrient-NTuple{4, Any}"><code>TMI.regeneratednutrient</code></a></li><li><a href="#TMI.regions_mat2nc-Tuple{Any, Any}"><code>TMI.regions_mat2nc</code></a></li><li><a href="#TMI.regionurl-Tuple{Any}"><code>TMI.regionurl</code></a></li><li><a href="../plots/#TMI.section"><code>TMI.section</code></a></li><li><a href="#TMI.section-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.section</code></a></li><li><a href="#TMI.setboundarycondition!-Tuple{Field, NamedTuple}"><code>TMI.setboundarycondition!</code></a></li><li><a href="../boundaries/#TMI.setboundarycondition!"><code>TMI.setboundarycondition!</code></a></li><li><a href="#TMI.setboundarycondition!-Tuple{Field, BoundaryCondition}"><code>TMI.setboundarycondition!</code></a></li><li><a href="#TMI.setsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.setsource!</code></a></li><li><a href="../grid/#TMI.shiftloc"><code>TMI.shiftloc</code></a></li><li><a href="#TMI.shiftloc-Tuple{Any, Any}"><code>TMI.shiftloc</code></a></li><li><a href="../grid/#TMI.southindex"><code>TMI.southindex</code></a></li><li><a href="#TMI.southindex-Tuple{Any}"><code>TMI.southindex</code></a></li><li><a href="#TMI.sparsedatamap_optim-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, Any, Vector, Any, Any, Grid}"><code>TMI.sparsedatamap_optim</code></a></li><li><a href="#TMI.standardize_fieldnames-Tuple{}"><code>TMI.standardize_fieldnames</code></a></li><li><a href="#TMI.steadyclimatology_optim-Tuple{Any, Any, Any}"><code>TMI.steadyclimatology_optim</code></a></li><li><a href="../utils/#TMI.steadyinversion"><code>TMI.steadyinversion</code></a></li><li><a href="#TMI.steadyinversion-Union{Tuple{T}, Tuple{Any, BoundaryCondition, Grid{T}}} where T&lt;:Real"><code>TMI.steadyinversion</code></a></li><li><a href="#TMI.step_cartesian-Union{Tuple{N}, Tuple{R}, Tuple{CartesianIndex{N}, CartesianIndex{N}, Grid{R, N}}} where {R, N}"><code>TMI.step_cartesian</code></a></li><li><a href="../legacy/#TMI.surfacecontrol2field"><code>TMI.surfacecontrol2field</code></a></li><li><a href="#TMI.surfacecontrol2field-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field</code></a></li><li><a href="../legacy/#TMI.surfacecontrol2field!"><code>TMI.surfacecontrol2field!</code></a></li><li><a href="#TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field!</code></a></li><li><a href="#TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field!</code></a></li><li><a href="../grid/#TMI.surfaceindex"><code>TMI.surfaceindex</code></a></li><li><a href="#TMI.surfaceindex-Tuple{Any}"><code>TMI.surfaceindex</code></a></li><li><a href="#TMI.surfaceorigin-Tuple{Any, Any, Grid}"><code>TMI.surfaceorigin</code></a></li><li><a href="../#TMI.surfaceorigin"><code>TMI.surfaceorigin</code></a></li><li><a href="#TMI.surfacepatch-Union{Tuple{R}, Tuple{Any, Any, Grid{R, 3}}} where R"><code>TMI.surfacepatch</code></a></li><li><a href="../grid/#TMI.surfacepatch"><code>TMI.surfacepatch</code></a></li><li><a href="../config/#TMI.surfaceregion"><code>TMI.surfaceregion</code></a></li><li><a href="#TMI.surfaceregion-Tuple{String, Union{String, Symbol}}"><code>TMI.surfaceregion</code></a></li><li><a href="#TMI.surfaceregion-Tuple{String, Union{String, Symbol}, Grid}"><code>TMI.surfaceregion</code></a></li><li><a href="../utils/#TMI.synthetic_observations"><code>TMI.synthetic_observations</code></a></li><li><a href="#TMI.synthetic_observations-Tuple{Any, Any, Any}"><code>TMI.synthetic_observations</code></a></li><li><a href="#TMI.synthetic_observations"><code>TMI.synthetic_observations</code></a></li><li><a href="../utils/#TMI.tracerinit"><code>TMI.tracerinit</code></a></li><li><a href="#TMI.tracerinit-Tuple{Any, Any, Any}"><code>TMI.tracerinit</code></a></li><li><a href="#TMI.trackpathways-NTuple{4, Any}"><code>TMI.trackpathways</code></a></li><li><a href="../#TMI.trackpathways"><code>TMI.trackpathways</code></a></li><li><a href="#TMI.unvec-Tuple{Union{NamedTuple, BoundaryCondition, Field}, Vector}"><code>TMI.unvec</code></a></li><li><a href="../utils/#TMI.unvec"><code>TMI.unvec</code></a></li><li><a href="#TMI.unvec!-Union{Tuple{T}, Tuple{Union{BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Vector{T}}} where T&lt;:Real"><code>TMI.unvec!</code></a></li><li><a href="../utils/#TMI.unvec!"><code>TMI.unvec!</code></a></li><li><a href="#TMI.vec2fld-Union{Tuple{T}, Tuple{Vector{T}, Vector{CartesianIndex{3}}}} where T&lt;:Real"><code>TMI.vec2fld</code></a></li><li><a href="#TMI.volumefilled-Tuple{Any, Any, Any}"><code>TMI.volumefilled</code></a></li><li><a href="../#TMI.volumefilled"><code>TMI.volumefilled</code></a></li><li><a href="#TMI.watermassdistribution-NTuple{4, Any}"><code>TMI.watermassdistribution</code></a></li><li><a href="../#TMI.watermassdistribution"><code>TMI.watermassdistribution</code></a></li><li><a href="#TMI.watermassmatrix-Tuple{Union{NamedTuple, Vector}, Grid}"><code>TMI.watermassmatrix</code></a></li><li><a href="../config/#TMI.watermassmatrix"><code>TMI.watermassmatrix</code></a></li><li><a href="#TMI.watermassmatrix-Tuple{Any}"><code>TMI.watermassmatrix</code></a></li><li><a href="#TMI.watermassmatrix-Tuple{SparseArrays.SparseMatrixCSC, Grid}"><code>TMI.watermassmatrix</code></a></li><li><a href="../grid/#TMI.westindex"><code>TMI.westindex</code></a></li><li><a href="#TMI.westindex-Tuple{Any}"><code>TMI.westindex</code></a></li><li><a href="#TMI.wetlocation-Tuple{Any}"><code>TMI.wetlocation</code></a></li><li><a href="../utils/#TMI.wetlocation"><code>TMI.wetlocation</code></a></li><li><a href="#TMI.write-Union{Tuple{T}, Tuple{Any, Union{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}}} where T&lt;:Real"><code>TMI.write</code></a></li><li><a href="#TMI.write-Union{Tuple{T}, Tuple{R}, Tuple{N}, Tuple{B}, Tuple{Any, BoundaryCondition{T, R, N, B, B1} where B1&lt;:AbstractArray{T, N}}} where {B&lt;:(AbstractMatrix), N&lt;:Integer, R&lt;:Real, T&lt;:Real}"><code>TMI.write</code></a></li><li><a href="../boundaries/#TMI.zeroeastboundary"><code>TMI.zeroeastboundary</code></a></li><li><a href="#TMI.zeroeastboundary"><code>TMI.zeroeastboundary</code></a></li><li><a href="../boundaries/#TMI.zeronorthboundary"><code>TMI.zeronorthboundary</code></a></li><li><a href="#TMI.zeronorthboundary"><code>TMI.zeronorthboundary</code></a></li><li><a href="#TMI.zerosouthboundary"><code>TMI.zerosouthboundary</code></a></li><li><a href="../boundaries/#TMI.zerosouthboundary"><code>TMI.zerosouthboundary</code></a></li><li><a href="../boundaries/#TMI.zerosurfaceboundary"><code>TMI.zerosurfaceboundary</code></a></li><li><a href="#TMI.zerosurfaceboundary"><code>TMI.zerosurfaceboundary</code></a></li><li><a href="#TMI.zerowestboundary"><code>TMI.zerowestboundary</code></a></li><li><a href="../boundaries/#TMI.zerowestboundary"><code>TMI.zerowestboundary</code></a></li><li><a href="#TMI.Γsfc!"><code>TMI.Γsfc!</code></a></li></ul><article><details class="docstring" open="true"><summary id="TMI.BoundaryCondition"><a class="docstring-binding" href="#TMI.BoundaryCondition"><code>TMI.BoundaryCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct BoundaryCondition

a plane defined at `dim=dimval`</code></pre><p><strong>Attributes</strong></p><pre><code class="language-julia hljs">`tracer::Array{T,2}`: values on plane
`i::Vector{T}`: coordinate values on local x-plane
`j::Vector{T}`: coordinate values on local y-plane
`k::T`: fixed coordinate value on local z-plane that defines the Boundary Condition plane
`dim::Int64`: dimension (1,2, or 3) along which the plane&#39;s index is fixed
`dimval::Int64`: plane defined at dim = dimval where dimval is a 1-based index number
`wet::BitArray{2}`: ocean mask for boundary condition</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.Field"><a class="docstring-binding" href="#TMI.Field"><code>TMI.Field</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Field</code></pre><p>This structure permits the grid to be   automatically passed to functions with  the tracer field.</p><p>This structure assumes the Tracer type to be   three-dimensional.</p><p>tracer::AbstractArray{T,N}  γ::Grid{A,N}  name::Symbol  longname::String  units::String</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/field.jl#L1-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.Grid"><a class="docstring-binding" href="#TMI.Grid"><code>TMI.Grid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Grid</code></pre><p>TMI grid with accounting for wet/dry points</p><p><strong>Fields</strong></p><ul><li><code>axes::NTuple{N,Vector{A}}</code>: labels for axis such as lon, lat, depth with element type <code>A</code></li><li><code>wet::BitArray{N}</code>: mask for ocean points</li><li><code>interior::BitArray{N}</code>: mask for interior ocean points</li><li><code>wrap::NTuple{N,Bool}</code>: does the domain wraparound in each dim?</li><li><code>Δ::Vector{CartesianIndex{N}}</code>: defines computational stencil relative to central cell</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/grid.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.Grid-Tuple{String}"><a class="docstring-binding" href="#TMI.Grid-Tuple{String}"><code>TMI.Grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function Grid(TMIfile)</code></pre><p>Construct the Grid given a file name</p><p><strong>Arguments</strong></p><ul><li><code>TMIfile::String</code>: NetCDF file name for TMI version</li></ul><p><strong>Output</strong></p><ul><li><p><code>γ::Grid</code>: TMI grid struct</p><p>function Grid(foreign_file, maskname, lonname, latname, depthname)</p></li></ul><p>Construct the Grid from a non-TMI file given the names of relevant fields.</p><p>Assumes that an ocean mask is available. Assumes an input NetCDF file. Assumes everything below the top layer is part of the interior.  Tested for Float32 fields (should work for other types).</p><p><strong>Arguments</strong></p><ul><li><code>foreign_file::String</code></li><li><code>maskname::String</code></li><li><code>lonname::String</code></li><li><code>latname::String</code></li><li><code>depthname::String</code></li></ul><p><strong>Output</strong></p><ul><li><code>γ::Grid</code>: TMI grid struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/grid.jl#L20-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.MassFraction"><a class="docstring-binding" href="#TMI.MassFraction"><code>TMI.MassFraction</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>struct MassFraction</p><p>store mass fractions in a Field-like array</p><ul><li><code>fraction::Array{T,3}</code></li><li><code>γ::Grid</code></li><li><code>name::Symbol</code></li><li><code>longname::String</code></li><li><code>units::String</code></li><li><code>position::CartesianIndex{3}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/mass_fractions.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.Source"><a class="docstring-binding" href="#TMI.Source"><code>TMI.Source</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Source

This structure describes Sources, which are
similar to Fields, but they may be
1) non-negative
2) have only interior mask</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/source.jl#L1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:\\-Union{Tuple{T}, Tuple{Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><a class="docstring-binding" href="#Base.:\\-Union{Tuple{T}, Tuple{Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">`function \(A,d::Field)::Field`
Define left division for Fields
Need two slashes to prevent invalid escape</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1241-L1245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.length-Tuple{Union{BoundaryCondition, Field, TMI.Source}}"><a class="docstring-binding" href="#Base.length-Tuple{Union{BoundaryCondition, Field, TMI.Source}}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.length(c::Union{Field,Source,BoundaryCondition}) = length(c.tracer[wet(c)])

Extend `length` to give the number of wet (i.e., ocean) gridcells.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1207-L1211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Tuple{Type{Field}}"><a class="docstring-binding" href="#Base.one-Tuple{Type{Field}}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function oneunit, help for gridded Interpolations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1104-L1107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{T}} where T&lt;:Real"><a class="docstring-binding" href="#Base.one-Union{Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{T}} where T&lt;:Real"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function oneunit, help for gridded Interpolations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1080-L1083">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.ones"><a class="docstring-binding" href="#Base.ones"><code>Base.ones</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function ones(γ::Grid,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;)::Field

  initialize tracer field of ones on TMI grid
  using a Field struct and constructor</code></pre><p><strong>Arguments</strong></p><ul><li><code>γ</code>::TMI.Grid</li></ul><p><strong>Output</strong></p><ul><li><code>d</code>::Field,  3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1052-L1062">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.ones-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer"><a class="docstring-binding" href="#Base.ones-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer"><code>Base.ones</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function ones(dim::Int64,dimval::Int64,γ::Grid)::BoundaryCondition

   Initialize boundary condition with ones</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L203-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.propertynames-Tuple{Grid}"><a class="docstring-binding" href="#Base.propertynames-Tuple{Grid}"><code>Base.propertynames</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.propertynames(γ::Grid) = (I,R,fieldnames(typeof(x))...)

Do not store Cartesian and linear indices.
Compute them on demand.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/grid.jl#L98-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.sum-Tuple{Field}"><a class="docstring-binding" href="#Base.sum-Tuple{Field}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Specialize Base.sum(c::Field)

so that it doesn&#39;t use the slow iteration method</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1227-L1231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.vec-Tuple{Field}"><a class="docstring-binding" href="#Base.vec-Tuple{Field}"><code>Base.vec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function vec(u)

Turn a collection of controls into a vector
for use with Optim.jl. 
An in-place version of this function would be handy.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1379-L1385">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.zero-Tuple{Field}"><a class="docstring-binding" href="#Base.zero-Tuple{Field}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">zero(c::Field) = zeros(c.γ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1197-L1199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.zeros"><a class="docstring-binding" href="#Base.zeros"><code>Base.zeros</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function zeros(wet,ltype=Float64)
initialize tracer field on TMI grid
This version will give an array</code></pre><p><strong>Arguments</strong></p><ul><li><code>wet</code>::BitArray mask of ocean points</li><li><code>ltype</code>:: optional type argument, default=Float64</li></ul><p><strong>Output</strong></p><ul><li><code>d</code>:: 3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1176-L1186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.zeros-Union{Tuple{Grid{T}}, Tuple{T}, Tuple{Grid{T}, Any}, Tuple{Grid{T}, Any, Any}, Tuple{Grid{T}, Any, Any, Any}} where T&lt;:Real"><a class="docstring-binding" href="#Base.zeros-Union{Tuple{Grid{T}}, Tuple{T}, Tuple{Grid{T}, Any}, Tuple{Grid{T}, Any, Any}, Tuple{Grid{T}, Any, Any, Any}} where T&lt;:Real"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function zeros(γ::Grid,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;)::Field

  initialize tracer field on TMI grid
  using a Field struct and constructor</code></pre><p><strong>Arguments</strong></p><ul><li><code>γ</code>::TMI.Grid</li></ul><p><strong>Output</strong></p><ul><li><code>d</code>::Field,  3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/field.jl#L33-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.zeros-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer"><a class="docstring-binding" href="#Base.zeros-Union{Tuple{I}, Tuple{I, I, Grid, Symbol, String, String}} where I&lt;:Integer"><code>Base.zeros</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function zeros(dim::Int64,dimval::Int64,γ::Grid,name::Symbol,longname::String,units::String)::BoundaryCondition

   Initialize boundary condition with zeroes</code></pre><p><strong>Arguments</strong></p><ul><li><code>dim</code>:</li><li><code>dimval</code></li><li><code>γ::Grid</code></li><li><code>name::Symbol</code></li><li><code>longname::String</code></li><li><code>units::String</code></li></ul><p><strong>Output</strong></p><ul><li><code>b::BoundaryCondition</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L180-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.dot-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><a class="docstring-binding" href="#LinearAlgebra.dot-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">`function *(c::Field,d::Field)::Field`
Field by field multiplication is element-by-element.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1338-L1341">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.add!-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Union{BoundaryCondition, Field, TMI.Source}"><a class="docstring-binding" href="#TMI.add!-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Union{BoundaryCondition, Field, TMI.Source}"><code>TMI.add!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">`function +(c::BoundaryCondition,d::BoundaryCondition)::BoundaryCondition`
Define addition for Fields</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1253-L1256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.adjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}"><a class="docstring-binding" href="#TMI.adjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.adjustboundarycondition!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function adjustboundarycondition!(b::Union{BoundaryCondition,NamedTuple},u::Union{BoundaryCondition,NamedTuple})

adjust all boundary conditions b that are described in u

warning: if u doesn&#39;t contain any boundary condition adjustments,
nothing will change.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L464-L471">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.adjustboundarycondition-Tuple{BoundaryCondition, BoundaryCondition}"><a class="docstring-binding" href="#TMI.adjustboundarycondition-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.adjustboundarycondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function adjustboundarycondition!(b::Union{BoundaryCondition,NamedTuple},u::Union{BoundaryCondition,NamedTuple})

adjust all boundary conditions b that are described in u</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L452-L456">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.axislabels-Tuple{String}"><a class="docstring-binding" href="#TMI.axislabels-Tuple{String}"><code>TMI.axislabels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function axislabels(file)</code></pre><p>Read and assemble the grid properties.</p><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li></ul><p><strong>Output</strong></p><ul><li><code>grid</code>: TMI grid coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L101-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.boundaryconditionatts-Union{Tuple{N}, Tuple{R}, Tuple{Integer, Integer, Grid{R, N}}} where {R, N}"><a class="docstring-binding" href="#TMI.boundaryconditionatts-Union{Tuple{N}, Tuple{R}, Tuple{Integer, Integer, Grid{R, N}}} where {R, N}"><code>TMI.boundaryconditionatts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function boundaryconditionatts(dim::Int64,dimval::Int64,γ::Grid)

   Help initialize boundary condition by getting some attributes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L161-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.boundarymask-Tuple{BoundaryCondition, Grid}"><a class="docstring-binding" href="#TMI.boundarymask-Tuple{BoundaryCondition, Grid}"><code>TMI.boundarymask</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> function boundarymask(b, γ::Grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L546-L548">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.boundarymask-Tuple{Grid}"><a class="docstring-binding" href="#TMI.boundarymask-Tuple{Grid}"><code>TMI.boundarymask</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function boundarymask(γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/grid.jl#L235-L237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.boundarymatrix-Tuple{Any, Any}"><a class="docstring-binding" href="#TMI.boundarymatrix-Tuple{Any, Any}"><code>TMI.boundarymatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    function boundarymatrix(file,γ)
Read and assemble the boundary matrix from MATLAB.
Transfer to updated x,y,z version</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI MATLAB file name</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>B</code>: boundary condition matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L226-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.boundarymatrix2nc-Tuple{Any, Any}"><a class="docstring-binding" href="#TMI.boundarymatrix2nc-Tuple{Any, Any}"><code>TMI.boundarymatrix2nc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Save boundary matrix for transient model to NetCDF file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L547-L549">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.cartesianindex-Tuple{String}"><a class="docstring-binding" href="#TMI.cartesianindex-Tuple{String}"><code>TMI.cartesianindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function cartesianindex(file)</code></pre><p>Read and assemble the grid coordinates according to the legacy MATLAB code (z,y,x order).</p><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li></ul><p><strong>Output</strong></p><ul><li><code>I</code>: TMI Cartesian index for wet points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L82-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.cartesianindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N"><a class="docstring-binding" href="#TMI.cartesianindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N"><code>TMI.cartesianindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function cartesianindex(wet)
Read and assemble the grid coordinates
according to a 3D tracer in x,y,z order</code></pre><p><strong>Arguments</strong></p><ul><li><code>wet</code>: BitArray logical mask for wet points</li></ul><p><strong>Output</strong></p><ul><li><code>I</code>: 3D Cartesian indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/grid.jl#L121-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.cellarea-Tuple{Any}"><a class="docstring-binding" href="#TMI.cellarea-Tuple{Any}"><code>TMI.cellarea</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Horizontal area of grid cell</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L729-L731">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.cellvolume-Tuple{Any}"><a class="docstring-binding" href="#TMI.cellvolume-Tuple{Any}"><code>TMI.cellvolume</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function cellvolume(γ)::Field

Volume of each grid cell.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L805-L809">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.checkgrid!-Tuple{Any, Any}"><a class="docstring-binding" href="#TMI.checkgrid!-Tuple{Any, Any}"><code>TMI.checkgrid!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function checkgrid!(c,wet)

perform a check of file compatibility
 with grid</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/grid.jl#L153-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.circulationmatrix-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.circulationmatrix-Tuple{Any, Any, Any}"><code>TMI.circulationmatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function circulationmatrix(file,A,γ)
Read and assemble the circulation matrix from the efficient storage of A and F₀ variables.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI MATLAB file name</li><li><code>A</code>: TMI water-mass matrix</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>L</code>: circulation matrix in xyz format</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L192-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.circulationmatrix-Tuple{Any, Any}"><a class="docstring-binding" href="#TMI.circulationmatrix-Tuple{Any, Any}"><code>TMI.circulationmatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function circulationmatrix(file,γ)
Read and assemble the circulation matrix from NetCDF.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI MATLAB file name</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>L</code>: circulation matrix in xyz format</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L169-L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.circulationmatrix2nc-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.circulationmatrix2nc-Tuple{Any, Any, Any}"><code>TMI.circulationmatrix2nc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Save circulation matrix <code>L</code> to NetCDF file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L497-L499">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.config-Tuple{Any}"><a class="docstring-binding" href="#TMI.config-Tuple{Any}"><code>TMI.config</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function config(TMIversion; compute_lu = true)
Configure TMI environment from NetCDF input file.</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: TMI version for water-mass/circulation model</li></ul><p><strong>Output</strong></p><ul><li><code>A</code>: TMI steady-state water-mass matrix</li><li><code>Alu</code>: LU decomposition of A</li><li><code>γ</code>: TMI grid properties</li><li><code>TMIfile</code>: TMI file name</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L2-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.config2nc-NTuple{5, Any}"><a class="docstring-binding" href="#TMI.config2nc-NTuple{5, Any}"><code>TMI.config2nc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Save TMI configuration to NetCDF format for non-proprietary access</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L337-L340">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.control2state-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.control2state-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T&lt;:Real"><code>TMI.control2state</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function control2state(tracer2D,γ)
turn 2D surface field into 3D field with zeroes below surface</code></pre><p><strong>Arguments</strong></p><ul><li><code>tracer2D</code>:: 2D surface tracer field</li><li><code>wet</code>::BitArray mask of ocean points</li></ul><p><strong>Output</strong></p><ul><li><code>tracer3D</code>:: 3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/deprecated.jl#L91-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.costfunction_gridded_model!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.costfunction_gridded_model!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real"><code>TMI.costfunction_gridded_model!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function costfunction_gridded_model!(J,guvec,convec::Vector{T},non_zero_indices,u₀::Union{BoundaryCondition{T},NamedTuple{&lt;:Any, NTuple{N2,BoundaryCondition{T}}}},c,y::Field{T},Wⁱ::Diagonal{T, Vector{T}},Qⁱ::Diagonal{T, Vector{T}},γ::Grid) where {N1, N2, T &lt;: Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1862-L1864">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.costfunction_gridded_model-Union{Tuple{T}, Tuple{Any, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.costfunction_gridded_model-Union{Tuple{T}, Tuple{Any, Any, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any, Vector{T}, Any, Any, LinearAlgebra.Diagonal{T, Vector{T}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid}} where T&lt;:Real"><code>TMI.costfunction_gridded_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function costfunction_gridded_model(convec::Vector{T},non_zero_indices,y::Field{T},u,A0,c,q,Wⁱ::Diagonal{T, Vector{T}},Qⁱ::Diagonal{T, Vector{T}},γ::Grid) where T &lt;: Real

squared model-data misfit for gridded data
controls are a vector input for Optim.jl</code></pre><p><strong>Arguments</strong></p><ul><li><code>convec</code>: concatenated control vecotr incuding u and f</li><li><code>J</code>: cost function of sum of squared misfits</li><li><code>gJ</code>: derivative of cost function wrt to controls</li><li><code>u</code>: tracer controls, field format</li><li><code>non_zero_indices</code>: Non-zero indices for reconstruction of water-mass matrix A</li><li><code>c</code>: tracer concentrations from GCM</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>Qⁱ</code>: inverse of Q weighting matrix for tracer conservation</li><li><code>γ</code>: grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1797-L1813">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.costfunction_gridded_obs!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Union{NamedTuple, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}, Union{NamedTuple, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid{T}}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.costfunction_gridded_obs!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Union{NamedTuple, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}, Union{NamedTuple, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid{T}}} where T&lt;:Real"><code>TMI.costfunction_gridded_obs!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function costfunction_gridded_obs!(J,guvec,uvec::Vector{T},Alu,b₀::Union{BoundaryCondition{T},NamedTuple{&lt;:Any, NTuple{N1,BoundaryCondition{T}}}},u₀::Union{BoundaryCondition{T},NamedTuple{&lt;:Any, NTuple{N2,BoundaryCondition{T}}}},y::Field{T},Wⁱ::Diagonal{T, Vector{T}},γ::Grid) where {N1, N2, T &lt;: Real}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1660-L1662">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.costfunction_gridded_obs-Union{Tuple{T}, Tuple{Any, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid{T}}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.costfunction_gridded_obs-Union{Tuple{T}, Tuple{Any, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, LinearAlgebra.Diagonal{T, Vector{T}}, Grid{T}}} where T&lt;:Real"><code>TMI.costfunction_gridded_obs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function costfunction_gridded_obs(uvec::Vector{T},Alu,b::BoundaryCondition{T},y::Field{T},Wⁱ::Diagonal{T, Vector{T}},γ::Grid) where T &lt;: Real

squared model-data misfit for gridded data
controls are a vector input for Optim.jl</code></pre><p><strong>Arguments</strong></p><ul><li><code>J</code>: cost function of sum of squared misfits</li><li><code>gJ</code>: derivative of cost function wrt to controls</li><li><code>u</code>: controls, field format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>b</code>: boundary conditions</li><li><code>y</code>: observations on grid</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>γ</code>: grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1627-L1642">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.costfunction_point_obs!-Tuple{Any, Union{Nothing, Vector}, Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}"><a class="docstring-binding" href="#TMI.costfunction_point_obs!-Tuple{Any, Union{Nothing, Vector}, Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}"><code>TMI.costfunction_point_obs!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function costfunction_point_obs!(J,guvec,uvec::Vector{T},Alu,b₀::BoundaryCondition{T},u₀::BoundaryCondition{T},y::Vector{T},Wⁱ::Diagonal{T, Vector{T}},wis,locs,Q⁻,γ::Grid) where T &lt;: Real

squared model-data misfit for pointwise data
controls are a vector input for Optim.jl
Issue #1: couldn&#39;t figure out how to nest with costfunction_obs!</code></pre><p><strong>Arguments</strong></p><ul><li><code>J</code>: cost function of sum of squared misfits</li><li><code>guvec</code>: derivative of cost function wrt to controls</li><li><code>uvec</code>: controls, vector format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>b</code>: boundary condition</li><li><code>y</code>: pointwise observations</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>wis</code>: weights for interpolation (data sampling, E)</li><li><code>locs</code>: data locations (lon,lat,depth)</li><li><code>Q⁻</code>: weights for control vector</li><li><code>γ</code>: grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1725-L1745">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.costfunction_point_obs-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}"><a class="docstring-binding" href="#TMI.costfunction_point_obs-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, LinearAlgebra.Diagonal, Any, Any, Any, Grid}"><code>TMI.costfunction_point_obs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function costfunction_point_obs(uvec::Vector{T},Alu,b₀::BoundaryCondition{T},u₀::BoundaryCondition{T},y::Vector{T},Wⁱ::Diagonal{T, Vector{T}},wis,locs,Q⁻,γ::Grid;q=nothing,r=1.0) where T &lt;: Real

Squared model-data misfit for pointwise data.
Controls are a vector input for Optim.jl.
Core numerics handled by `costfunction_point_obs`.</code></pre><p><strong>Arguments</strong></p><ul><li><code>uvec</code>: controls, vector format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>b</code>: boundary condition</li><li><code>y</code>: pointwise observations</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>wis</code>: weights for interpolation (data sampling, E)</li><li><code>locs</code>: data locations (lon,lat,depth)</li><li><code>Q⁻</code>: weights for control vector</li><li><code>γ</code>: grid</li></ul><p><strong>Optional</strong></p><ul><li><code>q::Field</code>: interior source</li><li><code>r::Number</code>: scalar factor for source</li></ul><p><strong>Output</strong></p><ul><li><code>J</code>: cost function of sum of squared misfits</li><li><code>gJ</code>: derivative of cost function wrt to controls</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1691-L1715">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.depthindex-Tuple{Any}"><a class="docstring-binding" href="#TMI.depthindex-Tuple{Any}"><code>TMI.depthindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function depthindex(I) 
Get the k-index (depth level) from the Cartesian index</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L661-L664">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.dirichletmatrix-Tuple{Grid, Any}"><a class="docstring-binding" href="#TMI.dirichletmatrix-Tuple{Grid, Any}"><code>TMI.dirichletmatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> function dirichletmatrix(γ, τ)</code></pre><p>Dirichlet surface boundary matrix with uniform timescale. Assumes that the Dirichlet boundary condition is zero.</p><p><strong>Arguments</strong></p><ul><li><code>γ</code>: TMI grid</li><li><code>τ</code>: uniform restoring timescale (years) for all boundary points </li></ul><p><strong>Output</strong></p><ul><li><code>Ldir</code>: circulation matrix in xyz format for boundary points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L275-L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.distancematrix-Tuple{Any}"><a class="docstring-binding" href="#TMI.distancematrix-Tuple{Any}"><code>TMI.distancematrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function distancematrix(γ;surface = true)

Matrix with size of surface points squared

Each entry gives distance in km between surface points
Gives only horizontal distance.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L757-L764">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.download_file-Tuple{String}"><a class="docstring-binding" href="#TMI.download_file-Tuple{String}"><code>TMI.download_file</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function download_file(TMIversion::String)

Download NetCDF file for given TMI version</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion::String</code></li></ul><p><strong>Output</strong></p><ul><li><code>TMIfile::String</code>: TMI file name</li></ul><p><strong>Side-effect</strong></p><ul><li>download TMI input file if necessary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L41-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.download_regionfile-Tuple{String}"><a class="docstring-binding" href="#TMI.download_regionfile-Tuple{String}"><code>TMI.download_regionfile</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function download_regionfile(TMIversion::String)</p><p>Return file name of regional masks.</p><p>Also download file from Google Drive, if not already done.</p><p>File name refers to the 2D size of domain. It is the same for modern and LGM configs and only depends on number of points in Nx and Ny directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/regions.jl#L37-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.eastindex-Tuple{Any}"><a class="docstring-binding" href="#TMI.eastindex-Tuple{Any}"><code>TMI.eastindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function eastindex(I) 
Get the vector index on the northern open boundary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L723-L726">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.effective_endmember-Tuple{Any, Any, Field, Any, Grid}"><a class="docstring-binding" href="#TMI.effective_endmember-Tuple{Any, Any, Field, Any, Grid}"><code>TMI.effective_endmember</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> function effective_endmember(TMIversion,Alu,field,region,γ)</code></pre><p>Effective (i.e., importance-weighted) endmember tracer value calculated according to Gebbie and Huybers 2011.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L393-L398">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.effective_endmember_sums-Tuple{Any, Field, BoundaryCondition, Grid}"><a class="docstring-binding" href="#TMI.effective_endmember_sums-Tuple{Any, Field, BoundaryCondition, Grid}"><code>TMI.effective_endmember_sums</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> function effective_endmember_sums(Alu,field::Field,b::BoundaryCondition,γ::Grid)</code></pre><p>Intermediate quantities for computing effective endmembers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L431-L435">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.fieldsatts-Tuple{}"><a class="docstring-binding" href="#TMI.fieldsatts-Tuple{}"><code>TMI.fieldsatts</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>All variable names and attributes. Useful for writing NetCDF files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L386-L389">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.gadjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}"><a class="docstring-binding" href="#TMI.gadjustboundarycondition!-Tuple{BoundaryCondition, BoundaryCondition}"><code>TMI.gadjustboundarycondition!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function gadjustboundarycondition!(b::BoundaryCondition{T},u::BoundaryCondition{T}) where T &lt;: Real

adjust the (one) boundary condition 
Just copy the variable.
Keep this function so that calling functions can look alike.
Could probably combine with lower function, use Union type</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L492-L499">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.gadjustboundarycondition-Union{Tuple{T}, Tuple{BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.gadjustboundarycondition-Union{Tuple{T}, Tuple{BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>TMI.gadjustboundarycondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function gadjustboundarycondition(gb::BoundaryCondition{T},u::BoundaryCondition{T}) where T &lt;: Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L484-L486">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.gaussiandistancematrix-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.gaussiandistancematrix-Tuple{Any, Any, Any}"><code>TMI.gaussiandistancematrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function gaussiandistancematrix(γ,σ,L)

uses distance matrix plus a lengthscale `L` (km)
and a size of the diagonal `σ`

returns values with inverse gaussian weighting</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L787-L794">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.getboundarycondition-Tuple{Field, Integer, Integer}"><a class="docstring-binding" href="#TMI.getboundarycondition-Tuple{Field, Integer, Integer}"><code>TMI.getboundarycondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function getboundarycondition(field::Field,dim,dimval)::BoundaryCondition Get boundary condition by extracting from Field (i.e., 3D tracer)</p><p><strong>Arguments</strong></p><ul><li><code>field::Field</code>: 3D tracer field with metadata and grid</li><li><code>dim</code>: dimension number (1,2,3) that the boundary plane has constant value</li><li><code>dimval</code>: index number in dimension <code>dim</code> that defines boundary plane</li></ul><p><strong>Output</strong></p><ul><li><code>b::BoundaryCondition</code>: boundary condition on a plane with metadata and grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L242-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.getboundarycondition-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{Field{T, R, N, F} where F&lt;:AbstractArray{T, N}, Integer, Integer, Grid}} where {T&lt;:Real, R&lt;:Real, N}"><a class="docstring-binding" href="#TMI.getboundarycondition-Union{Tuple{N}, Tuple{R}, Tuple{T}, Tuple{Field{T, R, N, F} where F&lt;:AbstractArray{T, N}, Integer, Integer, Grid}} where {T&lt;:Real, R&lt;:Real, N}"><code>TMI.getboundarycondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Get boundary condition by extracting from N-dimensional tracer and returning (N-1)-dimensional array</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L216-L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.geteastboundary-Tuple{Field}"><a class="docstring-binding" href="#TMI.geteastboundary-Tuple{Field}"><code>TMI.geteastboundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>geteastboundary(c::Field) = getboundarycondition(c,1,eastindex(c.γ))::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L354-L356">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.getnorthboundary-Tuple{Field}"><a class="docstring-binding" href="#TMI.getnorthboundary-Tuple{Field}"><code>TMI.getnorthboundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>getnorthboundary(c::Field) = getboundarycondition(c,2,northindex(c.γ))::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L349-L351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.getsouthboundary-Tuple{Field}"><a class="docstring-binding" href="#TMI.getsouthboundary-Tuple{Field}"><code>TMI.getsouthboundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>getsouthboundary(c::Field) = getboundarycondition(c,2,southindex(c.γ))::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L359-L361">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.getsurfaceboundary-Tuple{Field}"><a class="docstring-binding" href="#TMI.getsurfaceboundary-Tuple{Field}"><code>TMI.getsurfaceboundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>getsurfaceboundary(c::Field) = getboundarycondition(c,3,surfaceindex(c.γ))::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L344-L346">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.getwestboundary-Tuple{Field}"><a class="docstring-binding" href="#TMI.getwestboundary-Tuple{Field}"><code>TMI.getwestboundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>getwestboundary(c::Field) = getboundarycondition(c,1,westindex(c.γ))::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L364-L366">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.gobserve-Union{Tuple{T}, Tuple{Vector{T}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.gobserve-Union{Tuple{T}, Tuple{Vector{T}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.gobserve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function gobserve(gy::Vector{T},c::Field{T},wis,γ) where T &lt;: Real

ADJOINT Take a observation at location given by weights wis
Arguments not symmetric with `observe` due to splat operator</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1570-L1575">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.grid2nc-Tuple{Any, Any}"><a class="docstring-binding" href="#TMI.grid2nc-Tuple{Any, Any}"><code>TMI.grid2nc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Put grid properties (Cartesian index) into NetCDF file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L578-L580">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.griddicts-Tuple{Any}"><a class="docstring-binding" href="#TMI.griddicts-Tuple{Any}"><code>TMI.griddicts</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Save grid dictionaries of attributes for writing to NetCDF file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L366-L368">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.gridsize-Tuple{Any}"><a class="docstring-binding" href="#TMI.gridsize-Tuple{Any}"><code>TMI.gridsize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function gridsize(TMIversion)</code></pre><p>Parse the TMIversion string for the grid size</p><p>Will break if the prefix contains underscores or &#39;x&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L117-L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}}} where T&lt;:Real"><code>TMI.gsetboundarycondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function gsetboundarycondition(gd::Field{T},b::BoundaryCondition{T}) where T&lt;: Real

ADJOINT: apply boundary condition to the equation constraints</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>::Field, equation constraints (i.e., right hand side)</li><li><code>b</code>::BoundaryCondition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L395-L403">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, NamedTuple}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.gsetboundarycondition-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, NamedTuple}} where T&lt;:Real"><code>TMI.gsetboundarycondition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function gsetboundarycondition(gd::Field{T},b::BoundaryCondition{T}) where T&lt;: Real

ADJOINT: apply boundary condition to the equation constraints</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>::Field, equation constraints (i.e., right hand side)</li><li><code>b</code>::BoundaryCondition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L431-L439">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.gsetsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.gsetsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.gsetsource!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function gsetsource!(gq::Field{T},gd::Field{T},r=1.0)

Adjoint to `setsource!`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1362-L1366">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.gsteadyinversion-Tuple{Field, Any, Union{NamedTuple, BoundaryCondition}, Grid}"><a class="docstring-binding" href="#TMI.gsteadyinversion-Tuple{Field, Any, Union{NamedTuple, BoundaryCondition}, Grid}"><code>TMI.gsteadyinversion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function gsteadyinversion(gc,Alu,b;q=nothing,r=1.0)

ADJOINT invert for a steady-state tracer distribution</code></pre><p><strong>Arguments</strong></p><ul><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>b</code>: BoundaryCondition</li><li><code>γ</code>::Grid</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>q</code>: interior sources/sinks of phosphate</li><li><code>r</code>: stochiometric ratio of tracer:phosphate</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>::Field, steady-state tracer distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1937-L1952">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.horizontaldistance-Tuple{Any, Grid}"><a class="docstring-binding" href="#TMI.horizontaldistance-Tuple{Any, Grid}"><code>TMI.horizontaldistance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function horizontaldistance(loc,γ)</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: 3-tuple of lon,lat,depth location</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>hordist</code>: horizontal distance to nearest tracer grid points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L904-L912">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.interiormask-NTuple{5, Any}"><a class="docstring-binding" href="#TMI.interiormask-NTuple{5, Any}"><code>TMI.interiormask</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function interiormask(A,wet,nx,ny,nz)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/grid.jl#L190-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.interpindex-Tuple{Any, Any}"><a class="docstring-binding" href="#TMI.interpindex-Tuple{Any, Any}"><code>TMI.interpindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function interpindex(loc,γ)     Weights for linear interpolation.     The derivative of linear interpolation is needed in sensitivity studies.     ReverseDiff.jl could find this quantity automatically.     Instead we dig into the Interpolations.jl package to find the weights that are effectively the partial derivatives of the function.</p><p><strong>Arguments</strong></p><ul><li><code>c</code>: a temporary tracer field, would be nice to make it unnecessary</li><li><code>loc</code>: (lon,lat,depth) tuple of a location of interest</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>δ</code>: weights on a 3D tracer field grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L930-L942">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.interpweights-Tuple{Any, Any}"><a class="docstring-binding" href="#TMI.interpweights-Tuple{Any, Any}"><code>TMI.interpweights</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function interpweights(loc,γ)     Weights for linear interpolation.     The derivative of linear interpolation is needed in sensitivity studies.     ReverseDiff.jl could find this quantity automatically.     Instead we dig into the Interpolations.jl package to find the weights that are effectively the partial derivatives of the function.</p><p><strong>Arguments</strong></p><ul><li><code>loc</code>: (lon,lat,depth) tuple of a location of interest</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>δ</code>: weights on a 3D tracer field grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L988-L999">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.iswet-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.iswet-Tuple{Any, Any, Any}"><code>TMI.iswet</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function iswet(loc, γ, neighbors)
Get (lon,lat,depth) tuples of wet locations.
Allow a location to be wet if at least one out of 8 nearby gridpoints is wet.
Certainly &quot;wet&quot; gridpoints could be defined more strictly.</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: lon,lat,depth</li><li><code>γ</code></li><li><code>neighbors</code></li></ul><p><strong>Output</strong></p><ul><li>Boolean (true for ocean point)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L2042-L2053">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.latindex-Tuple{Any}"><a class="docstring-binding" href="#TMI.latindex-Tuple{Any}"><code>TMI.latindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function latindex(I) 
Get the j-index (latitude index) from the Cartesian index</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L683-L686">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.linearindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N"><a class="docstring-binding" href="#TMI.linearindex-Union{Tuple{BitArray{N}}, Tuple{N}} where N"><code>TMI.linearindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function linearindex(wet)
Read and assemble the grid coordinates.</code></pre><p><strong>Arguments</strong></p><ul><li><code>wet</code>: 3D mask for wet points</li></ul><p><strong>Output</strong></p><ul><li><code>R</code>: array of linear indices, but not a LinearIndices type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/grid.jl#L138-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.local_watermass_matrix-Tuple{NamedTuple, Union{NamedTuple, Vector}, CartesianIndex, Field}"><a class="docstring-binding" href="#TMI.local_watermass_matrix-Tuple{NamedTuple, Union{NamedTuple, Vector}, CartesianIndex, Field}"><code>TMI.local_watermass_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function <code>local_watermass_matrix(c::NamedTuple,     m::NamedTuple,     I::CartesianIndex,     neighbors::Field)</code> Find local water-mass matrix with singularity checker (<code>true</code> if one neighbor only has a single connection to the rest of the ocean)</p><p><strong>Arguments</strong></p><ul><li><code>c::NamedTuple</code>: input tracers</li><li><code>m::NamedTuple</code>: mass fractions for grid stencil</li><li><code>I::CartesianIndex</code>: local &quot;location&quot;</li><li><code>neighbors::Field</code>: integer number of neighbors</li></ul><p><strong>Output</strong></p><ul><li><code>A::Matrix</code>: local water-mass matrix</li><li><code>single_connection::Bool</code>: true if flagged for singularity warning</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/mass_fractions.jl#L465-L481">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.location_obs-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.location_obs-Tuple{Any, Any, Any}"><code>TMI.location_obs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function location_obs(field, locs, γ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1588-L1590">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.lonindex-Tuple{Any}"><a class="docstring-binding" href="#TMI.lonindex-Tuple{Any}"><code>TMI.lonindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function lonindex(I) 
Get the i-index (lon index) from the Cartesian index</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L672-L675">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.matfields2nc_orig-Tuple{Any, Any}"><a class="docstring-binding" href="#TMI.matfields2nc_orig-Tuple{Any, Any}"><code>TMI.matfields2nc_orig</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Read 3D fields from mat file and save to NetCDF file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/deprecated.jl#L133-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.matrix_modern2glacial-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.matrix_modern2glacial-Tuple{Any, Any, Any}"><code>TMI.matrix_modern2glacial</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    function matrix_mod2glacial(Amodern,γmodern,γglacial)

Transfer modern water-mass matrix Amod to glacial water-mass matrix Aglacial</code></pre><p><strong>Arguments</strong></p><ul><li><code>Amodern</code>: modern water-mass matrix</li><li><code>γmodern</code>: modern TMI grid</li><li><code>γglacial</code>: glacial TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>Aglacial</code>: glacial water-mass matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L662-L672">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.meanage-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.meanage-Tuple{Any, Any, Any}"><code>TMI.meanage</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function meanage(TMIversion,Alu,γ)
Mean or ideal age</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>a</code>: mean age [yr]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L232-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.mixedlayermask-Tuple{Any, Grid}"><a class="docstring-binding" href="#TMI.mixedlayermask-Tuple{Any, Grid}"><code>TMI.mixedlayermask</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function mixedlayermask(A,γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/grid.jl#L210-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.mixedlayermatrix-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.mixedlayermatrix-Tuple{Any, Any, Any}"><code>TMI.mixedlayermatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> function mixedlayermatrix(A, γ, τ)</code></pre><p>Read and assemble the circulation matrix from the efficient storage of A and F₀ variables. </p><p><strong>Arguments</strong></p><ul><li><code>A</code>: TMI water-mass matrix</li><li><code>γ</code>: TMI grid</li><li><code>τ</code>: uniform residence timescale (years) for all mixed layer points </li></ul><p><strong>Output</strong></p><ul><li><code>Lmix</code>: circulation matrix in xyz format for mixed layer points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L251-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.ncurl-Tuple{Any}"><a class="docstring-binding" href="#TMI.ncurl-Tuple{Any}"><code>TMI.ncurl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function ncurl(TMIversion)
placeholder function to give location (URL) of NetCDF Google Drive input
in the future, consider a struct or Dict that describes all TMI versions.</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li></ul><p><strong>Output</strong></p><ul><li><code>url</code>: location (URL) for download</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L300-L309">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.nearestneighbor"><a class="docstring-binding" href="#TMI.nearestneighbor"><code>TMI.nearestneighbor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function nearestneighbor(loc,γ)
return the Cartesian index and linear index 
of the nearest N neighbors</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: 3-tuple of lon,lat,depth location</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>Inn</code>: Cartesian indices of nearest neighbor</li></ul><p>#- <code>Rnn</code>: linear indices of nearest neighbor, Removed from code</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L864-L874">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.nearestneighbormask"><a class="docstring-binding" href="#TMI.nearestneighbormask"><code>TMI.nearestneighbormask</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function nearestneighbormask
Make a 3D tracer field that is 1 at location 
of nearest neighbor, 0 elsewhere</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: location in a 3-tuple (lon,lat,depth)</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>δ</code>: nearest neighbor mask 3D field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L842-L851">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.neighbor_indices"><a class="docstring-binding" href="#TMI.neighbor_indices"><code>TMI.neighbor_indices</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>function <code>neighbor_indices(n::Integer)</code></p><p>Direction (step) of neighbors away from a central point. Choose n = 6 (default) or n=26. </p><p><strong>Argument</strong></p><ul><li><code>n=6</code>: max number of neighbors</li></ul><p><strong>Output</strong></p><ul><li><code>In::Vector{CartesianIndex}</code>: indices of neighbors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/mass_fractions.jl#L160-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.neighbors-Union{Tuple{Grid{R, N}}, Tuple{N}, Tuple{R}} where {R, N}"><a class="docstring-binding" href="#TMI.neighbors-Union{Tuple{Grid{R, N}}, Tuple{N}, Tuple{R}} where {R, N}"><code>TMI.neighbors</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function <code>neighbors(γ::Grid;     longname = &quot;number of neighbors&quot;)</code></p><p>How many neighbors does each grid cell have? Conceptually, it only depends on the grid, but this algorithm is slower than the one that takes mass fractions as input.</p><p><strong>Arguments</strong></p><ul><li><code>γ::TMI.Grid</code></li></ul><p><strong>Output</strong></p><ul><li><code>n::Field</code>: integer number of neighbors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/mass_fractions.jl#L272-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.neighbors-Union{Tuple{N}, Tuple{R}, Tuple{Union{NamedTuple, Vector}, Grid{R, N}}} where {R, N}"><a class="docstring-binding" href="#TMI.neighbors-Union{Tuple{N}, Tuple{R}, Tuple{Union{NamedTuple, Vector}, Grid{R, N}}} where {R, N}"><code>TMI.neighbors</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function <code>neighbors(m::NamedTuple,γ::Grid)</code></p><p>How many neighbors does each grid cell have?</p><p><strong>Arguments</strong></p><ul><li><code>m::NamedTuple</code>: input mass fractions to obtain their stencil (opportunity to simplify)</li><li><code>γ::TMI.Grid</code></li></ul><p><strong>Output</strong></p><ul><li><code>n::Field</code>: integer number of neighbors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/mass_fractions.jl#L238-L247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.northindex-Tuple{Any}"><a class="docstring-binding" href="#TMI.northindex-Tuple{Any}"><code>TMI.northindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function northindex(I) 
Get the vector index on the northern open boundary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L711-L714">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}}, 1}, Grid}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}, Interpolations.WeightedAdjIndex{2, T}}, 1}, Grid}} where T&lt;:Real"><code>TMI.observe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function observe
Take a observation at location given by weights wis</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1532-L1535">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{T, T, T}, 1}, Grid}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.observe-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Array{Tuple{T, T, T}, 1}, Grid}} where T&lt;:Real"><code>TMI.observe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function observe(c,loc,γ)

Extend the TMI.observe method to use locations rather than weighted interpolations.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1554-L1558">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.oneeastboundary"><a class="docstring-binding" href="#TMI.oneeastboundary"><code>TMI.oneeastboundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>oneeastboundary(γ,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;) = ones(1,eastindex(γ),γ,name,longname,units)::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L329-L331">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.onenorthboundary"><a class="docstring-binding" href="#TMI.onenorthboundary"><code>TMI.onenorthboundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>onenorthboundary(γ,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;) = ones(2,northindex(γ),γ,name,longname,units)::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L324-L326">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.onesouthboundary"><a class="docstring-binding" href="#TMI.onesouthboundary"><code>TMI.onesouthboundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>onesouthboundary(γ,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;) = ones(2,southindex(γ),γ,name,longname,units)::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L334-L336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.onesurfaceboundary"><a class="docstring-binding" href="#TMI.onesurfaceboundary"><code>TMI.onesurfaceboundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>onesurfaceboundary(γ,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;) = ones(3,surfaceindex(γ),γ,name,longname,units)::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L319-L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.onewestboundary"><a class="docstring-binding" href="#TMI.onewestboundary"><code>TMI.onewestboundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>onewestboundary(γ,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;) = ones(1,westindex(γ),γ,name,longname,units)::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L339-L341">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.optim2nc-Tuple{Any}"><a class="docstring-binding" href="#TMI.optim2nc-Tuple{Any}"><code>TMI.optim2nc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Save optimization parameters to NetCDF file)</p><p>Future considerations: split into 2 functions</p><ol><li>read from mat</li><li>save to nc</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L463-L469">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.preformedcarbon13-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.preformedcarbon13-Tuple{Any, Any, Any}"><code>TMI.preformedcarbon13</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>preformedcarbon13(TMIversion,Alu,γ) = preformednutrient(&quot;δ¹³C&quot;,TMIversion,Alu,γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L227-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.preformednitrate-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.preformednitrate-Tuple{Any, Any, Any}"><code>TMI.preformednitrate</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>preformednitrate(TMIversion,Alu,γ) = preformednutrient(&quot;NO₃&quot;,TMIversion,Alu,γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L217-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.preformednutrient-Tuple{Union{String, Symbol}, Any, Any, Any}"><a class="docstring-binding" href="#TMI.preformednutrient-Tuple{Union{String, Symbol}, Any, Any, Any}"><code>TMI.preformednutrient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function preformednutrient(tracer::Union{String,Symbol},TMIversion,Alu,γ)

Preformed (i.e., NO accumulation or remineralization) nutrient</code></pre><p><strong>Arguments</strong></p><ul><li><code>tracer::Union{Symbol,String}</code>: tracer name</li><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>c★</code>: preformed tracer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L187-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.preformedoxygen-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.preformedoxygen-Tuple{Any, Any, Any}"><code>TMI.preformedoxygen</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>preformedoxygen(TMIversion,Alu,γ) = preformednutrient(&quot;O₂&quot;,TMIversion,Alu,γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L222-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.preformedphosphate-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.preformedphosphate-Tuple{Any, Any, Any}"><code>TMI.preformedphosphate</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>preformedphosphate(TMIversion,Alu,γ) = preformednutrient(&quot;PO₄&quot;,TMIversion,Alu,γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L212-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.readfield-Union{Tuple{N}, Tuple{A}, Tuple{Any, Any, Grid{A, N}}} where {A, N}"><a class="docstring-binding" href="#TMI.readfield-Union{Tuple{N}, Tuple{A}, Tuple{Any, Any, Grid{A, N}}} where {A, N}"><code>TMI.readfield</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function readfield(file,tracername,γ)
Read a tracer field from NetCDF but return it 
as a Field.

Use NCDatasets so that Unicode is correct</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li><li><code>tracername</code>: name of tracer</li><li><code>γ::Grid</code>, TMI grid specification</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>::Field</li></ul><hr/><pre><code class="language-julia hljs">MATLAB version
function readfield(matfile,mattracername,γ::Grid,Izyx) # for MATLAB

read MATLAB field and transfer zyx format to xyz</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/field.jl#L89-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.readtracer-Tuple{Any, Any}"><a class="docstring-binding" href="#TMI.readtracer-Tuple{Any, Any}"><code>TMI.readtracer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function readtracer(file,tracername)
Read a tracer field from NetCDF.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li><li><code>tracername</code>: name of tracer</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>: 3D tracer field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/deprecated.jl#L209-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.regeneratednutrient-NTuple{4, Any}"><a class="docstring-binding" href="#TMI.regeneratednutrient-NTuple{4, Any}"><code>TMI.regeneratednutrient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function regeneratednutrient(TMIversion,Alu,γ)

Regenerated (i.e., accumulated, remineralized) nutrient</code></pre><p><strong>Arguments</strong></p><ul><li><code>tracer::Union{String,Symbol}</code>: tracer name</li><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>γ</code>: TMI grid</li><li><code>r</code>: optional stoichiometric ratio relative to PO₄</li></ul><p><strong>Output</strong></p><ul><li><code>PO₄ᴿ</code>: regenerated phosphate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L147-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.regions_mat2nc-Tuple{Any, Any}"><a class="docstring-binding" href="#TMI.regions_mat2nc-Tuple{Any, Any}"><code>TMI.regions_mat2nc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function regions2nc(TMIversion,γ)</p><p>Read vectors from mat file, translate to 3D, and save surface field to NetCDF file.</p><p>Consider deprecating this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/regions.jl#L111-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.regionurl-Tuple{Any}"><a class="docstring-binding" href="#TMI.regionurl-Tuple{Any}"><code>TMI.regionurl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function regionurl(TMIversion)
placeholder function to give location (URL) of NetCDF Google Drive input
in the future, consider a struct or Dict that describes all TMI versions.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: name of file to look for on Google Drive</li></ul><p><strong>Output</strong></p><ul><li><code>regionurl</code>: location (URL) for download of regional mask file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/regions.jl#L66-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.section-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.section-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.section</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function section
View latitude-depth slice of field</code></pre><p><strong>Arguments</strong></p><ul><li><code>c::Field</code>, 3D tracer field plus meta data</li><li><code>lon</code>: longitude of section</li></ul><p><strong>Output</strong></p><ul><li><code>csection</code>: 2d slice of field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/field.jl#L65-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.setboundarycondition!-Tuple{Field, BoundaryCondition}"><a class="docstring-binding" href="#TMI.setboundarycondition!-Tuple{Field, BoundaryCondition}"><code>TMI.setboundarycondition!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function setboundarycondition!(d::Field,b::BoundaryCondition)
apply boundary condition to the equation constraints</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>::Field, equation constraints (i.e., right hand side)</li><li><code>b</code>::BoundaryCondition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L375-L382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.setboundarycondition!-Tuple{Field, NamedTuple}"><a class="docstring-binding" href="#TMI.setboundarycondition!-Tuple{Field, NamedTuple}"><code>TMI.setboundarycondition!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function setboundarycondition!(d::Field{T},b::NamedTuple{&lt;:Any, NTuple{N,BoundaryCondition{T}}}) where {N, T &lt;: Real}

set all boundary conditions in a Named Tuple</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L420-L424">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.setsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.setsource!-Union{Tuple{T}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Tuple{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, Any}} where T&lt;:Real"><code>TMI.setsource!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function setsource!(d::Field,q::Field,r::Number)
apply interior source q to the equation constraints d</code></pre><p><strong>Arguments</strong></p><ul><li><code>d</code>::Field, equation constraints (i.e., right hand side)</li><li><code>q</code>::Field, interior source</li><li><code>r</code>::Number, default = 1.0, stoichiometric ratio</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1347-L1355">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.shiftloc-Tuple{Any, Any}"><a class="docstring-binding" href="#TMI.shiftloc-Tuple{Any, Any}"><code>TMI.shiftloc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function  shiftloc(loc)</p><pre><code class="language-julia hljs">sometimes loc longitudes are outside of grid due to different conventions
assumption: 360° shift is enough to get back on grid</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L962-L967">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.southindex-Tuple{Any}"><a class="docstring-binding" href="#TMI.southindex-Tuple{Any}"><code>TMI.southindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function southindex(I) 
Get the vector-index on the southern open boundary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L705-L708">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.sparsedatamap_optim-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, Any, Vector, Any, Any, Grid}"><a class="docstring-binding" href="#TMI.sparsedatamap_optim-Tuple{Vector, Any, Union{NamedTuple, BoundaryCondition}, Union{NamedTuple, BoundaryCondition}, Vector, Any, Vector, Any, Any, Grid}"><code>TMI.sparsedatamap_optim</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function sparsedatamap(u₀::Vector{T},Alu,b::BoundaryCondition{T},u::BoundaryCondition{T},y::Vector{T},W⁻,wis,locs,Q⁻,γ::Grid;iterations=10) where T &lt;: Real

 Find the distribution of a tracer given:
 (a) the pathways described by A or its LU decomposition Alu,
 (b) first-guess boundary conditions and interior sources given by d₀,
 (c) perturbations to the surface boundary condition u₀
that best fits observations, y,
according to the cost function,
J = (ỹ - y)ᵀ W⁻¹ (ỹ - y)
subject to Aỹ = d₀ + Γ u₀.                 
W⁻ is a (sparse) weighting matrix.
See Supplementary Section 2, Gebbie &amp; Huybers 2011.</code></pre><p><strong>Arguments</strong></p><ul><li><code>u₀</code>:</li><li><code>Alu</code>:</li><li><code>b</code>: first guess of boundary conditions and interior sources</li><li><code>y</code>: observations on 3D grid</li><li><code>W⁻</code>: weighting matrix best chosen as inverse error covariance matrix</li><li><code>fg!</code>: compute cost function and gradient in place</li><li><code>γ</code>: grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L531-L552">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.standardize_fieldnames-Tuple{}"><a class="docstring-binding" href="#TMI.standardize_fieldnames-Tuple{}"><code>TMI.standardize_fieldnames</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function mat2ncfield

Rename MATLAB variables to NetCDF variables</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/field.jl#L153-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.steadyclimatology_optim-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.steadyclimatology_optim-Tuple{Any, Any, Any}"><code>TMI.steadyclimatology_optim</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function steadyclimatology_optim(u₀,fg!,iterations)      Find the distribution of a tracer given:      (a) the pathways described by A or its LU decomposition Alu,      (b) first-guess boundary conditions and interior sources given by d₀,      (c) perturbations to the surface boundary condition u₀     that best fits observations, y,     according to the cost function,     J = (ỹ - y)ᵀ W⁻¹ (ỹ - y)     subject to Aỹ = d₀ + Γ u₀.                      W⁻ is a (sparse) weighting matrix.     See Supplementary Section 2, Gebbie &amp; Huybers 2011.</p><p><strong>Arguments</strong></p><ul><li><code>u₀</code>:</li><li><code>fg!</code>: compute cost function and gradient in place</li><li><code>iterations</code>: number of optimization iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L489-L505">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.steadyinversion-Union{Tuple{T}, Tuple{Any, BoundaryCondition, Grid{T}}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.steadyinversion-Union{Tuple{T}, Tuple{Any, BoundaryCondition, Grid{T}}} where T&lt;:Real"><code>TMI.steadyinversion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function steadyinversion(Alu,b;q=nothing,r=1.0)
invert for a steady-state tracer distribution</code></pre><p><strong>Arguments</strong></p><ul><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>b</code>: boundary condition, assumed to be surface boundary condition</li><li><code>γ</code>::Grid</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>q</code>: interior sources/sinks of phosphate</li><li><code>r</code>: stochiometric ratio of tracer:phosphate</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>::Field, steady-state tracer distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1906-L1919">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.step_cartesian-Union{Tuple{N}, Tuple{R}, Tuple{CartesianIndex{N}, CartesianIndex{N}, Grid{R, N}}} where {R, N}"><a class="docstring-binding" href="#TMI.step_cartesian-Union{Tuple{N}, Tuple{R}, Tuple{CartesianIndex{N}, CartesianIndex{N}, Grid{R, N}}} where {R, N}"><code>TMI.step_cartesian</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function <code>step_cartesian(I, Δ, γ)</code></p><p><strong>Arguments</strong></p><ul><li><code>I::CartesianIndex</code>: starting point</li><li><code>Δ::CartesianIndex</code>: step</li><li><code>γ::Grid</code>: TMI-defined grid</li></ul><p><strong>Output</strong></p><ul><li><code>Istep::CartesianIndex</code>: new location</li><li><code>inbounds::Bool</code>: inside the domain bounds?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/mass_fractions.jl#L98-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{T}, Any}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function surfacecontrol2field!(c,u,γ)
Add surface control vector to existing 3D field</code></pre><p><strong>Arguments</strong></p><ul><li><code>c</code>:: state field, 3d tracer field with NaN on dry points, modified by function</li><li><code>usfc</code>:: surface control vector</li><li><code>wet</code>::BitArray mask of ocean points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/deprecated.jl#L32-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Any}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.surfacecontrol2field!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function surfacecontrol2field!(c,u,γ)
Add surface control vector to tracer vector</code></pre><p><strong>Arguments</strong></p><ul><li><code>c</code>:: state field, 3d tracer field with NaN on dry points, modified by function</li><li><code>u</code>:: surface control vector</li><li><code>wet</code>::BitArray mask of ocean points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/deprecated.jl#L47-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.surfacecontrol2field-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.surfacecontrol2field-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real"><code>TMI.surfacecontrol2field</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function surfacecontrol2field(usfc,γ.wet)
turn surface control vector into 3D field with zeroes below surface</code></pre><p><strong>Arguments</strong></p><ul><li><code>usfc</code>:: surface control vector</li><li><code>wet</code>::BitArray mask of ocean points</li></ul><p><strong>Output</strong></p><ul><li><code>tracer3D</code>:: 3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/deprecated.jl#L112-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.surfaceindex-Tuple{Any}"><a class="docstring-binding" href="#TMI.surfaceindex-Tuple{Any}"><code>TMI.surfaceindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function surfaceindex(I) 
Get the vector-index where depth level == 1 and it is ocean.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L699-L702">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.surfaceorigin-Tuple{Any, Any, Grid}"><a class="docstring-binding" href="#TMI.surfaceorigin-Tuple{Any, Any, Grid}"><code>TMI.surfaceorigin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function surfaceorigin(TMIversion,loc)
 Find the surface origin of water for some interior box 
 This is equivalent to solving a sensitivity problem:
 The mass fraction at a location `loc` of interest is 
`c[loc] = δᵀ c`, where `δ` samples the location of the global mass-fraction variable, c.
Then the sensitivity of `c[loc]` is: d(c[loc])/d(d) = A⁻ᵀ δ.
The derivative is solved using the constraint: Ac = d.
The sensitivity is exactly the mass fraction originating from each source.      
This problem is mathematically similar to determining how the ocean is filled.</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: location (lon,lat,depth) of location of interest</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>origin</code>: surface map of fraction of source water for a given location, log10 of effective depth, in terms of a BoundaryCondition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L454-L471">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.surfacepatch-Union{Tuple{R}, Tuple{Any, Any, Grid{R, 3}}} where R"><a class="docstring-binding" href="#TMI.surfacepatch-Union{Tuple{R}, Tuple{Any, Any, Grid{R, 3}}} where R"><code>TMI.surfacepatch</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function surfacepatch
Make a surface boundary condition
with a rectangular patch</code></pre><p><strong>Arguments</strong></p><ul><li><code>lonbox</code>: longitudes of box edges</li><li><code>latbox</code>: latitudes of box edges</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>d</code>: vector that describes surface patch</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L257-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.surfaceregion-Tuple{String, Union{String, Symbol}, Grid}"><a class="docstring-binding" href="#TMI.surfaceregion-Tuple{String, Union{String, Symbol}, Grid}"><code>TMI.surfaceregion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> function surfaceregion(TMIversion::String,region::String,γ::Grid)::BoundaryCondition

Read an oceanographically-relevant surface region from NetCDF file. (Also could be read from mat file.)</code></pre><p>Return a BoundaryCondition</p><pre><code class="language-julia hljs">Version 1: operates on a 2D Float field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/deprecated.jl#L174-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.surfaceregion-Tuple{String, Union{String, Symbol}}"><a class="docstring-binding" href="#TMI.surfaceregion-Tuple{String, Union{String, Symbol}}"><code>TMI.surfaceregion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> function surfaceregion(TMIversion::String,region::String,γ::Grid)::BoundaryCondition

Read an oceanographically-relevant surface region from NetCDF file. (Also could be read from mat file.)
Return a BoundaryCondition</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/regions.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.synthetic_observations"><a class="docstring-binding" href="#TMI.synthetic_observations"><code>TMI.synthetic_observations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function synthetic_observations(TMIversion,variable,locs)
Synthetic observations that are a contaminated version of real observations
This version: observations with random (uniform) spatial sampling</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion::String</code>: version of TMI water-mass/circulation model</li><li><code>variable::String</code>: variable name to use as template</li><li><code>N</code>: number of observations</li></ul><p><strong>Output</strong></p><ul><li><code>y</code>: contaminated observations on 3D grid</li><li><code>W⁻</code>: appropriate weighting (inverse covariance) matrix for these observations,</li><li><code>ytrue</code>: uncontaminated observations, 3D field</li><li><code>locs</code>: 3-tuples of locations for observations</li><li><code>wis</code>: weighted indices for interpolation to locs sites</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1476-L1491">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.synthetic_observations-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.synthetic_observations-Tuple{Any, Any, Any}"><code>TMI.synthetic_observations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function synthetic_observations(TMIversion,variable)
Synthetic observations that are a contaminated version of real observations
This version: gridded observations</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion::String</code>: version of TMI water-mass/circulation model</li><li><code>variable::String</code>: variable name to use as template</li></ul><p><strong>Output</strong></p><ul><li><code>y</code>: contaminated observations on 3D grid</li><li><code>W⁻</code>: appropriate weighting (inverse covariance) matrix for these observations,</li><li><code>θtrue</code>: real observations, 3D field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1437-L1449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.tracerinit-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.tracerinit-Tuple{Any, Any, Any}"><code>TMI.tracerinit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function tracerinit(wet,vec,I)
      initialize tracer field on TMI grid
    perhaps better to have a tracer struct and constructor</code></pre><p><strong>Arguments</strong></p><ul><li><code>wet</code>:: BitArray mask of ocean points</li><li><code>vec</code>:: vector of values at wet points</li><li><code>I</code>:: Cartesian Index for vector</li></ul><p><strong>Output</strong></p><ul><li><code>field</code>:: 3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L606-L617">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.trackpathways-NTuple{4, Any}"><a class="docstring-binding" href="#TMI.trackpathways-NTuple{4, Any}"><code>TMI.trackpathways</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function trackpathways(TMIversion,latbox,lonbox)
Track the pathways of a user-defined water mass.
 Steps: (a) define the water mass by a rectangular surface patch dyed with passive tracer concentration of         (b) propagate the dye with the matrix A, with the result being the fraction of water originating from the surface region.
 See Section 2b of Gebbie &amp; Huybers 2010, esp. eqs. (15)-(17).</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>latbox</code>: min and max latitude of box</li><li><code>lonbox</code>: min and max longitude of box</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>: fraction of water from surface source</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L105-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.unvec!-Union{Tuple{T}, Tuple{Union{BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Vector{T}}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.unvec!-Union{Tuple{T}, Tuple{Union{BoundaryCondition{T, R, N, G, B} where {R&lt;:Real, N, G&lt;:Integer, B&lt;:AbstractArray{T, N}}, Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}, Vector{T}}} where T&lt;:Real"><code>TMI.unvec!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function unvec!(u,uvec)

Undo the operations by vec(u)
Needs to update u because attributes of 
u need to be known at runtime.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1414-L1420">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.unvec-Tuple{Union{NamedTuple, BoundaryCondition, Field}, Vector}"><a class="docstring-binding" href="#TMI.unvec-Tuple{Union{NamedTuple, BoundaryCondition, Field}, Vector}"><code>TMI.unvec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function unvec(u,uvec)

Replace u with new u
Undo the operations by vec(u)
Needs to update u because attributes of 
u need to be known at runtime.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L1400-L1407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.vec2fld-Union{Tuple{T}, Tuple{Vector{T}, Vector{CartesianIndex{3}}}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.vec2fld-Union{Tuple{T}, Tuple{Vector{T}, Vector{CartesianIndex{3}}}} where T&lt;:Real"><code>TMI.vec2fld</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function vec2fld
Transfer a vector to a 3D field with accounting for ocean bathymetry</code></pre><p><strong>Arguments</strong></p><ul><li><code>vector</code>: field in vector form (no land points)</li><li><code>I</code>: cartesian indices of ocean points</li></ul><p><strong>Output</strong></p><ul><li><code>field</code>: field in 3d form including land points (NaN)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/deprecated.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.volumefilled-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TMI.volumefilled-Tuple{Any, Any, Any}"><code>TMI.volumefilled</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function volumefilled(TMIversion)
Find the ocean volume that has originated from each surface box.
 This is equivalent to solving a sensitivity problem:
 The total volume is V = vᵀ c , where v is the volume of each box 
 and c is the fraction of volume from a given source which
 satisfies the equation A c = d.                     
 Next, dV/d(d) = A⁻ᵀ v, and dV/d(d) is exactly the volume originating from each source.

 See Section 3 and Supplementary Section 4, Gebbie &amp; Huybers 2011.</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>volume</code>: log10 of global ocean volume filled by a surface region, exists at surface, therefore given BoundaryCondition type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L347-L364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.watermassdistribution-NTuple{4, Any}"><a class="docstring-binding" href="#TMI.watermassdistribution-NTuple{4, Any}"><code>TMI.watermassdistribution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function watermassdistribution(TMIversion,latbox,lonbox)
Track the pathways of a user-defined water mass.
 Steps: (a) define the water mass by an oceanographically-relevant surface patch dyed with passive tracer concentration of one
     (b) propagate the dye with the matrix A, with the result being the fraction of water originating from the surface region.
 See Section 2b of Gebbie &amp; Huybers 2010, esp. eqs. (15)-(17).</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>Alu</code>: LU decomposition of water-mass matrix A</li><li><code>region</code>: name of pre-defined surface region</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>g</code>: water-mass fraction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L126-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.watermassmatrix-Tuple{Any}"><a class="docstring-binding" href="#TMI.watermassmatrix-Tuple{Any}"><code>TMI.watermassmatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function watermassmatrix(file)
Read and assemble the water-mass matrix.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF or MATLAB file name</li></ul><p><strong>Output</strong></p><ul><li><code>A</code>: water-mass matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/config.jl#L133-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.watermassmatrix-Tuple{SparseArrays.SparseMatrixCSC, Grid}"><a class="docstring-binding" href="#TMI.watermassmatrix-Tuple{SparseArrays.SparseMatrixCSC, Grid}"><code>TMI.watermassmatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>update water-mass matrix to agree with new boundaries in γ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L529-L531">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.watermassmatrix-Tuple{Union{NamedTuple, Vector}, Grid}"><a class="docstring-binding" href="#TMI.watermassmatrix-Tuple{Union{NamedTuple, Vector}, Grid}"><code>TMI.watermassmatrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>function watermassmatrix(m::Union{NamedTuple,Vector}, γ::Grid)</code></p><p>Produce water-mass matrix from mass fractions and grid.</p><p><strong>Arguments</strong></p><ul><li><code>m::NamedTuple</code>: collection of <code>MassFraction</code>s</li><li><code>γ::TMI.Grid</code></li></ul><p><strong>Output</strong></p><ul><li><code>A</code>: sparse water-mass matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/mass_fractions.jl#L362-L373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.westindex-Tuple{Any}"><a class="docstring-binding" href="#TMI.westindex-Tuple{Any}"><code>TMI.westindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function westindex(I) 
Get the vector index on the western open boundary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L717-L720">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.wetlocation-Tuple{Any}"><a class="docstring-binding" href="#TMI.wetlocation-Tuple{Any}"><code>TMI.wetlocation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function wetlocation(γ)
Get (lon,lat,depth) tuples of wet locations.
Allow a location to be wet if at least one out of 8 nearby gridpoints is wet.
Certainly &quot;wet&quot; gridpoints could be defined more strictly.</code></pre><p><strong>Arguments</strong></p><ul><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>loc</code>: lon,lat,depth </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L2019-L2027">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.write-Union{Tuple{T}, Tuple{Any, Union{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}}} where T&lt;:Real"><a class="docstring-binding" href="#TMI.write-Union{Tuple{T}, Tuple{Any, Union{Field{T, R, N, F} where {R&lt;:Real, N, F&lt;:AbstractArray{T, N}}, TMI.Source{T, A, N, F} where {A&lt;:Real, N, F&lt;:AbstractArray{T, N}}}}} where T&lt;:Real"><code>TMI.write</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function writefield(file,field)

Write a Field to NetCDF.

Use NCDatasets so that Unicode is correct</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li><li><code>field::Field</code>: a TMI.Field struct</li></ul><p><strong>Output</strong></p><ul><li>none</li></ul><p><strong>Side-effect</strong></p><ul><li>write to <code>file</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/TMI.jl#L595-L609">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.write-Union{Tuple{T}, Tuple{R}, Tuple{N}, Tuple{B}, Tuple{Any, BoundaryCondition{T, R, N, B, B1} where B1&lt;:AbstractArray{T, N}}} where {B&lt;:(AbstractMatrix), N&lt;:Integer, R&lt;:Real, T&lt;:Real}"><a class="docstring-binding" href="#TMI.write-Union{Tuple{T}, Tuple{R}, Tuple{N}, Tuple{B}, Tuple{Any, BoundaryCondition{T, R, N, B, B1} where B1&lt;:AbstractArray{T, N}}} where {B&lt;:(AbstractMatrix), N&lt;:Integer, R&lt;:Real, T&lt;:Real}"><code>TMI.write</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function write(file,b)

Write a BoundaryCondition to NetCDF.

Use NCDatasets so that Unicode is correct</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li><li><code>b::BoundaryCondition</code>: a TMI.BoundaryCondition struct</li></ul><p><strong>Output</strong></p><ul><li>none</li></ul><p><strong>Side-effect</strong></p><ul><li>write to <code>file</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L72-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.zeroeastboundary"><a class="docstring-binding" href="#TMI.zeroeastboundary"><code>TMI.zeroeastboundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>zeroeastboundary(γ,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;) = zeros(1,eastindex(γ),γ,name,longname,units)::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L304-L306">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.zeronorthboundary"><a class="docstring-binding" href="#TMI.zeronorthboundary"><code>TMI.zeronorthboundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>zeronorthboundary(γ,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;) = zeros(2,northindex(γ),γ,name,longname,units)::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L299-L301">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.zerosouthboundary"><a class="docstring-binding" href="#TMI.zerosouthboundary"><code>TMI.zerosouthboundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>zerosouthboundary(γ,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;) = zeros(2,southindex(γ),γ,name,longname,units)::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L309-L311">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.zerosurfaceboundary"><a class="docstring-binding" href="#TMI.zerosurfaceboundary"><code>TMI.zerosurfaceboundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>zerosurfaceboundary(γ::Grid,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;) = zeros(3,surfaceindex(γ),γ,name,longname,units)::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L294-L296">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.zerowestboundary"><a class="docstring-binding" href="#TMI.zerowestboundary"><code>TMI.zerowestboundary</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>zerowestboundary(γ,name=:none,longname=&quot;unknown&quot;,units=&quot;unknown&quot;) = zeros(1,westindex(γ),γ,name,longname,units)::BoundaryCondition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/boundary_condition.jl#L314-L316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TMI.Γsfc!"><a class="docstring-binding" href="#TMI.Γsfc!"><code>TMI.Γsfc!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function Γsfc! 
Γsfc! anonymously calls surfacecontrol2field!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/5d6bfda6944ce26b709c4fff53cbcb4e9b9b7bdc/src/deprecated.jl#L60-L63">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../utils/">« Utilities</a><a class="docs-footer-nextpage" href="../legacy/">Older functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 27 November 2025 00:14">Thursday 27 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
