<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TMI.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://ggebbie.github.io/TMI.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TMI.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ggebbie/TMI.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TMI"><a class="docs-heading-anchor" href="#TMI">TMI</a><a id="TMI-1"></a><a class="docs-heading-anchor-permalink" href="#TMI" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/ggebbie/TMI.jl">TMI</a>.</p><ul><li><a href="#TMI.cartesianindexXYZ-Tuple{Any}"><code>TMI.cartesianindexXYZ</code></a></li><li><a href="#TMI.cartesianindexZYX-Tuple{Any}"><code>TMI.cartesianindexZYX</code></a></li><li><a href="#TMI.config-Tuple{Any}"><code>TMI.config</code></a></li><li><a href="#TMI.control2state-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T&lt;:Real"><code>TMI.control2state</code></a></li><li><a href="#TMI.control2state-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real"><code>TMI.control2state</code></a></li><li><a href="#TMI.control2state!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.control2state!</code></a></li><li><a href="#TMI.control2state!-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.control2state!</code></a></li><li><a href="#TMI.costfunction-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, Any, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction</code></a></li><li><a href="#TMI.costfunction!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, Any, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction!</code></a></li><li><a href="#TMI.costfunction_obs-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction_obs</code></a></li><li><a href="#TMI.costfunction_obs-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, Array{T, 3}, LinearAlgebra.Diagonal{T, Vector{T}}, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction_obs</code></a></li><li><a href="#TMI.costfunction_obs!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Array{T, 3}, Array{T, 3}, LinearAlgebra.Diagonal{T, Vector{T}}, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction_obs!</code></a></li><li><a href="#TMI.costfunction_obs!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction_obs!</code></a></li><li><a href="#TMI.depthindex-Tuple{Any}"><code>TMI.depthindex</code></a></li><li><a href="#TMI.download-Tuple{Any, Any}"><code>TMI.download</code></a></li><li><a href="#TMI.dyeplot-NTuple{4, Any}"><code>TMI.dyeplot</code></a></li><li><a href="#TMI.filterdata-NTuple{7, Any}"><code>TMI.filterdata</code></a></li><li><a href="#TMI.fld2vec-Tuple{Array{Float64, 3}, Vector{CartesianIndex{3}}}"><code>TMI.fld2vec</code></a></li><li><a href="#TMI.gdriveurl-Tuple{Any}"><code>TMI.gdriveurl</code></a></li><li><a href="#TMI.gridprops-Tuple{Any}"><code>TMI.gridprops</code></a></li><li><a href="#TMI.horizontaldistance-Tuple{Any, TMI.grid}"><code>TMI.horizontaldistance</code></a></li><li><a href="#TMI.interpindex-Tuple{Any, Any}"><code>TMI.interpindex</code></a></li><li><a href="#TMI.interpweights-Tuple{Any, Any}"><code>TMI.interpweights</code></a></li><li><a href="#TMI.linearindexXYZ-Tuple{Any}"><code>TMI.linearindexXYZ</code></a></li><li><a href="#TMI.nearestneighbor"><code>TMI.nearestneighbor</code></a></li><li><a href="#TMI.nearestneighbormask"><code>TMI.nearestneighbormask</code></a></li><li><a href="#TMI.plotextent-Tuple{Any, Any}"><code>TMI.plotextent</code></a></li><li><a href="#TMI.readtracer-Tuple{Any, Any}"><code>TMI.readtracer</code></a></li><li><a href="#TMI.regeneratedphosphate-Tuple{Any}"><code>TMI.regeneratedphosphate</code></a></li><li><a href="#TMI.sample_observations-Tuple{Any, Any}"><code>TMI.sample_observations</code></a></li><li><a href="#TMI.sample_observations-Tuple{Any, Any, Any}"><code>TMI.sample_observations</code></a></li><li><a href="#TMI.section-Tuple{Any, Any, Any}"><code>TMI.section</code></a></li><li><a href="#TMI.steady_inversion-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, BitArray{3}}} where T&lt;:Real"><code>TMI.steady_inversion</code></a></li><li><a href="#TMI.surfaceindex-Tuple{Any}"><code>TMI.surfaceindex</code></a></li><li><a href="#TMI.surfaceorigin-Tuple{Any, Any}"><code>TMI.surfaceorigin</code></a></li><li><a href="#TMI.surfacepatch-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, TMI.grid}} where T&lt;:Real"><code>TMI.surfacepatch</code></a></li><li><a href="#TMI.tracerinit"><code>TMI.tracerinit</code></a></li><li><a href="#TMI.trackpathways-Tuple{Any, Any, Any}"><code>TMI.trackpathways</code></a></li><li><a href="#TMI.updatelinearindex-Tuple{Any, Any, Any}"><code>TMI.updatelinearindex</code></a></li><li><a href="#TMI.vec2fld-Tuple{Vector{Float64}, Vector{CartesianIndex{3}}}"><code>TMI.vec2fld</code></a></li><li><a href="#TMI.volumefilled-Tuple{Any}"><code>TMI.volumefilled</code></a></li><li><a href="#TMI.watermassmatrix-Tuple{Any}"><code>TMI.watermassmatrix</code></a></li><li><a href="#TMI.watermassmatrixXYZ-Tuple{Any, Any}"><code>TMI.watermassmatrixXYZ</code></a></li><li><a href="#TMI.watermassmatrixZYX-Tuple{Any}"><code>TMI.watermassmatrixZYX</code></a></li><li><a href="#TMI.wetlocation-Tuple{Any}"><code>TMI.wetlocation</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TMI.cartesianindexXYZ-Tuple{Any}" href="#TMI.cartesianindexXYZ-Tuple{Any}"><code>TMI.cartesianindexXYZ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function cartesianindexXYZ(wet)
Read and assemble the grid coordinates
according to a 3D tracer in x,y,z order</code></pre><p><strong>Arguments</strong></p><ul><li><code>wet</code>: BitArray logical mask for wet points</li></ul><p><strong>Output</strong></p><ul><li><code>I</code>: 3D Cartesian indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L138-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.cartesianindexZYX-Tuple{Any}" href="#TMI.cartesianindexZYX-Tuple{Any}"><code>TMI.cartesianindexZYX</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function cartesianindexZYX(file)
Read and assemble the grid coordinates
according to the legacy MATLAB code (z,y,x order).</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li></ul><p><strong>Output</strong></p><ul><li><code>grid</code>: TMI grid coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L120-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.config-Tuple{Any}" href="#TMI.config-Tuple{Any}"><code>TMI.config</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function config(url,inputdir)</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: TMI version for water-mass/circulation model</li></ul><p><strong>Output</strong></p><ul><li><code>A</code>: TMI steady-state water-mass matrix</li><li><code>Alu</code>: LU decomposition of A</li><li><code>γ</code>: TMI grid properties</li><li><code>TMIfile</code>: TMI file name</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L64-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.control2state!-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{T}, Any}} where T&lt;:Real" href="#TMI.control2state!-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.control2state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function control2state!(c,u,γ)
Add surface control vector to existing 3D field</code></pre><p><strong>Arguments</strong></p><ul><li><code>c</code>:: state field, 3d tracer field with NaN on dry points, modified by function</li><li><code>u</code>:: surface control vector</li><li><code>wet</code>::BitArray mask of ocean points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L763-L771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.control2state!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Any}} where T&lt;:Real" href="#TMI.control2state!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Any}} where T&lt;:Real"><code>TMI.control2state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function control2state!(c,u,γ)
Add surface control vector to existing 3D field</code></pre><p><strong>Arguments</strong></p><ul><li><code>c</code>:: state field, 3d tracer field with NaN on dry points, modified by function</li><li><code>u</code>:: surface control vector</li><li><code>wet</code>::BitArray mask of ocean points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L778-L786">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.control2state-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T&lt;:Real" href="#TMI.control2state-Union{Tuple{T}, Tuple{Matrix{T}, Any}} where T&lt;:Real"><code>TMI.control2state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function control2state(tracer2D,γ)
turn 2D surface field into 3D field with zeroes below surface</code></pre><p><strong>Arguments</strong></p><ul><li><code>tracer2D</code>:: 2D surface tracer field</li><li><code>wet</code>::BitArray mask of ocean points</li></ul><p><strong>Output</strong></p><ul><li><code>tracer3D</code>:: 3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L721-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.control2state-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real" href="#TMI.control2state-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T&lt;:Real"><code>TMI.control2state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function control2state(u,γ)
turn surface control vector into 3D field with zeroes below surface</code></pre><p><strong>Arguments</strong></p><ul><li><code>u</code>:: surface control vector</li><li><code>wet</code>::BitArray mask of ocean points</li></ul><p><strong>Output</strong></p><ul><li><code>tracer3D</code>:: 3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L742-L751">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.costfunction!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, Any, TMI.grid}} where T&lt;:Real" href="#TMI.costfunction!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, Any, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function costfunction!(J,gJ,u,Alu,dfld,yfld,Wⁱ,wis,Q⁻,γ)
squared model-data misfit for pointwise data
controls are a vector input for Optim.jl
Issue: couldn&#39;t figure out how to nest with costfunction_obs!</code></pre><p><strong>Arguments</strong></p><ul><li><code>J</code>: cost function of sum of squared misfits</li><li><code>gJ</code>: derivative of cost function wrt to controls</li><li><code>u</code>: controls, vector format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>dfld</code>: model constraints</li><li><code>y</code>: pointwise observations</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>wis</code>: weights for interpolation (data sampling, E)</li><li><code>locs</code>: data locations (lon,lat,depth)</li><li><code>Q⁻</code>: weights for control vector</li><li><code>γ</code>: grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L1437-L1455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.costfunction-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, Any, TMI.grid}} where T&lt;:Real" href="#TMI.costfunction-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, Any, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function costfunction(J,gJ,u,Alu,dfld,yfld,Wⁱ,wis,Q⁻,γ)
squared model-data misfit for pointwise data
controls are a vector input for Optim.jl
Issue: couldn&#39;t figure out how to nest with costfunction_obs!</code></pre><p><strong>Arguments</strong></p><ul><li><code>u</code>: controls, vector format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>dfld</code>: model constraints</li><li><code>y</code>: pointwise observations</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>wis</code>: weights for interpolation (data sampling, E)</li><li><code>locs</code>: data locations (lon,lat,depth)</li><li><code>Q⁻</code>: weights for control vector</li><li><code>γ</code>: grid</li></ul><p><strong>Output</strong></p><ul><li><code>J</code>: cost function of sum of squared misfits</li><li><code>gJ</code>: derivative of cost function wrt to controls</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L1384-L1403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.costfunction_obs!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Array{T, 3}, Array{T, 3}, LinearAlgebra.Diagonal{T, Vector{T}}, TMI.grid}} where T&lt;:Real" href="#TMI.costfunction_obs!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Array{T, 3}, Array{T, 3}, LinearAlgebra.Diagonal{T, Vector{T}}, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction_obs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function costfunction_obs(u,Alu,y,d,Wⁱ,wet)
squared model-data misfit for gridded data
controls are a vector input for Optim.jl</code></pre><p><strong>Arguments</strong></p><ul><li><code>J</code>: cost function of sum of squared misfits</li><li><code>gJ</code>: derivative of cost function wrt to controls</li><li><code>u</code>: controls, vector format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>d</code>: model constraints</li><li><code>y</code>: observations on grid</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>γ</code>: grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L1246-L1260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.costfunction_obs!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, TMI.grid}} where T&lt;:Real" href="#TMI.costfunction_obs!-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction_obs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function costfunction_obs!(J,gJ,u,Alu,dfld,yfld,Wⁱ,wis,locs,γ)
squared model-data misfit for pointwise data
controls are a vector input for Optim.jl</code></pre><p><strong>Arguments</strong></p><ul><li><code>J</code>: cost function of sum of squared misfits</li><li><code>gJ</code>: derivative of cost function wrt to controls</li><li><code>u</code>: controls, vector format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>dfld</code>: model constraints</li><li><code>y</code>: pointwise observations</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>wis</code>: weights for interpolation (data sampling, E)</li><li><code>locs</code>: data locations (lon,lat,depth)</li><li><code>γ</code>: grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L1335-L1351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.costfunction_obs-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, Array{T, 3}, LinearAlgebra.Diagonal{T, Vector{T}}, TMI.grid}} where T&lt;:Real" href="#TMI.costfunction_obs-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, Array{T, 3}, LinearAlgebra.Diagonal{T, Vector{T}}, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction_obs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function costfunction_obs(u,Alu,dfld,yfld,Wⁱ,γ)
squared model-data misfit for gridded data
controls are a vector input for Optim.jl</code></pre><p><strong>Arguments</strong></p><ul><li><code>u</code>: controls, vector format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>y</code>: observations on grid</li><li><code>d</code>: model constraints</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>wet</code>: BitArray ocean mask</li></ul><p><strong>Output</strong></p><ul><li><code>J</code>: cost function of sum of squared misfits</li><li><code>gJ</code>: derivative of cost function wrt to controls</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L1191-L1206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.costfunction_obs-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, TMI.grid}} where T&lt;:Real" href="#TMI.costfunction_obs-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, Vector{T}, LinearAlgebra.Diagonal{T, Vector{T}}, Any, Any, TMI.grid}} where T&lt;:Real"><code>TMI.costfunction_obs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function costfunction_obs(u,Alu,dfld,yfld,Wⁱ,wis,locs,γ)
squared model-data misfit for pointwise data
controls are a vector input for Optim.jl</code></pre><p><strong>Arguments</strong></p><ul><li><code>u</code>: controls, vector format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>y</code>: pointwise observations</li><li><code>d</code>: model constraints</li><li><code>Wⁱ</code>: inverse of W weighting matrix for observations</li><li><code>wis</code>: weights for interpolation </li><li><code>locs</code>: data locations</li><li><code>γ</code>: grid</li></ul><p><strong>Output</strong></p><ul><li><code>J</code>: cost function of sum of squared misfits</li><li><code>gJ</code>: derivative of cost function wrt to controls</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L1287-L1304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.depthindex-Tuple{Any}" href="#TMI.depthindex-Tuple{Any}"><code>TMI.depthindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function depthindex(I) 
Get the k-index (depth level) from the Cartesian index</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L682-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.download-Tuple{Any, Any}" href="#TMI.download-Tuple{Any, Any}"><code>TMI.download</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function download(url,inputdir)
Read and assemble all TMI inputs.</code></pre><p><strong>Arguments</strong></p><ul><li><code>url</code>: Google Drive location of TMI input</li><li><code>inputdir</code>: input directory location to store file</li></ul><p><strong>Output</strong></p><ul><li>none</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L413-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.dyeplot-NTuple{4, Any}" href="#TMI.dyeplot-NTuple{4, Any}"><code>TMI.dyeplot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function dyeplot
Plot of dye in ocean</code></pre><p><strong>Arguments</strong></p><ul><li><code>lat</code>: latitude arrays</li><li><code>depth</code>: depth array</li><li><code>vals</code>: lat x depth value array</li><li><code>lims</code>: contour levels</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L665-L673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.filterdata-NTuple{7, Any}" href="#TMI.filterdata-NTuple{7, Any}"><code>TMI.filterdata</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function filterdata(u₀,Alu,y,d₀,W⁻,γ)      Find the distribution of a tracer given:      (a) the pathways described by A or its LU decomposition Alu,      (b) first-guess boundary conditions and interior sources given by d₀,      (c) perturbations to the surface boundary condition u₀     that best fits observations, y,     according to the cost function,     J = (ỹ - y)ᵀ W⁻¹ (ỹ - y)     subject to Aỹ = d₀ + Γ u₀.                      W⁻ is a (sparse) weighting matrix.     See Supplementary Section 2, Gebbie &amp; Huybers 2011.</p><p><strong>Arguments</strong></p><ul><li><code>u₀</code>:</li><li><code>Alu</code>:</li><li><code>d₀</code>: first guess of boundary conditions and interior sources</li><li><code>y</code>: observations on 3D grid</li><li><code>W⁻</code>: weighting matrix best chosen as inverse error covariance matrix</li><li><code>fg!</code>: compute cost function and gradient in place</li><li><code>γ</code>: grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L1030-L1050">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.fld2vec-Tuple{Array{Float64, 3}, Vector{CartesianIndex{3}}}" href="#TMI.fld2vec-Tuple{Array{Float64, 3}, Vector{CartesianIndex{3}}}"><code>TMI.fld2vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function fld2vec
Transfer 3D field with accounting for ocean bathymetry to a vector without land points</code></pre><p><strong>Arguments</strong></p><ul><li><code>field</code>: field in 3d form including land points (NaN)</li><li><code>I</code>: cartesian indices of ocean points</li></ul><p><strong>Output</strong></p><ul><li><code>vector</code>: field in vector form (no land points)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L456-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.gdriveurl-Tuple{Any}" href="#TMI.gdriveurl-Tuple{Any}"><code>TMI.gdriveurl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function gdriveurl(TMIversion)
placeholder function to give location (URL) of Google Drive input
in the future, consider a struct or Dict that describes all TMI versions.</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li></ul><p><strong>Output</strong></p><ul><li><code>url</code>: location (URL) for download</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L841-L850">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.gridprops-Tuple{Any}" href="#TMI.gridprops-Tuple{Any}"><code>TMI.gridprops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function gridprops(file)
Read and assemble the grid properties.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li></ul><p><strong>Output</strong></p><ul><li><code>grid</code>: TMI grid coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L168-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.horizontaldistance-Tuple{Any, TMI.grid}" href="#TMI.horizontaldistance-Tuple{Any, TMI.grid}"><code>TMI.horizontaldistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function horizontaldistance(loc,γ)
return the Cartesian index and linear index 
of the nearest N neighbors</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: 3-tuple of lon,lat,depth location</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>hordist</code>: horizontal distance to nearest tracer grid points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L567-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.interpindex-Tuple{Any, Any}" href="#TMI.interpindex-Tuple{Any, Any}"><code>TMI.interpindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function interpindex(loc,γ)     Weights for linear interpolation.     The derivative of linear interpolation is needed in sensitivity studies.     ReverseDiff.jl could find this quantity automatically.     Instead we dig into the Interpolations.jl package to find the weights that are effectively the partial derivatives of the function.</p><p><strong>Arguments</strong></p><ul><li><code>c</code>: a temporary tracer field, would be nice to make it unnecessary</li><li><code>loc</code>: (lon,lat,depth) tuple of a location of interest</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>δ</code>: weights on a 3D tracer field grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L953-L965">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.interpweights-Tuple{Any, Any}" href="#TMI.interpweights-Tuple{Any, Any}"><code>TMI.interpweights</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function interpweights(loc,γ)     Weights for linear interpolation.     The derivative of linear interpolation is needed in sensitivity studies.     ReverseDiff.jl could find this quantity automatically.     Instead we dig into the Interpolations.jl package to find the weights that are effectively the partial derivatives of the function.</p><p><strong>Arguments</strong></p><ul><li><code>loc</code>: (lon,lat,depth) tuple of a location of interest</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>δ</code>: weights on a 3D tracer field grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L982-L993">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.linearindexXYZ-Tuple{Any}" href="#TMI.linearindexXYZ-Tuple{Any}"><code>TMI.linearindexXYZ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function linearindexXYZ(file)
Read and assemble the grid coordinates.</code></pre><p><strong>Arguments</strong></p><ul><li><code>wet</code>: 3D mask for wet points</li></ul><p><strong>Output</strong></p><ul><li><code>R</code>: array of linear indices, but not a LinearIndices type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L149-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.nearestneighbor" href="#TMI.nearestneighbor"><code>TMI.nearestneighbor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function nearestneighbor(loc,γ)
return the Cartesian index and linear index 
of the nearest N neighbors</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: 3-tuple of lon,lat,depth location</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>Inn</code>: Cartesian indices of nearest neighbor</li></ul><p>#- <code>Rnn</code>: linear indices of nearest neighbor, Removed from code</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L527-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.nearestneighbormask" href="#TMI.nearestneighbormask"><code>TMI.nearestneighbormask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function nearestneighbormask
Make a 3D tracer field that is 1 at location 
of nearest neighbor, 0 elsewhere</code></pre><p><strong>Arguments</strong></p><ul><li><code>loc</code>: location in a 3-tuple (lon,lat,depth)</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>δ</code>: nearest neighbor mask 3D field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L505-L514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.plotextent-Tuple{Any, Any}" href="#TMI.plotextent-Tuple{Any, Any}"><code>TMI.plotextent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function plotextent
Generate image showing user-specified ROI</code></pre><p><strong>Arguments</strong></p><ul><li><code>latbox</code>: in format [lat<em>start, lat</em>stop]</li><li><code>lonbox</code>: in format [lon<em>start, lon</em>stop]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L619-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.readtracer-Tuple{Any, Any}" href="#TMI.readtracer-Tuple{Any, Any}"><code>TMI.readtracer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function readtracer(file,tracername)
Read and assemble the water-mass matrix.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li><li><code>tracername</code>: name of tracer</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>: 3D tracer field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L351-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.regeneratedphosphate-Tuple{Any}" href="#TMI.regeneratedphosphate-Tuple{Any}"><code>TMI.regeneratedphosphate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function regeneratedphosphate(TMIversion)
Regenerated (i.e., accumulated, remineralized) phosphate</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li></ul><p><strong>Output</strong></p><ul><li><code>PO₄ᴿ</code>: regenerated phosphate</li><li><code>γ</code>: TMI grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L859-L868">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.sample_observations-Tuple{Any, Any, Any}" href="#TMI.sample_observations-Tuple{Any, Any, Any}"><code>TMI.sample_observations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sample_observations(TMIversion,variable,locs)
Synthetic observations that are a contaminated version of real observations
This version: observations with random (uniform) spatial sampling</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion::String</code>: version of TMI water-mass/circulation model</li><li><code>variable::String</code>: variable name to use as template</li><li><code>N</code>: number of observations</li></ul><p><strong>Output</strong></p><ul><li><code>y</code>: contaminated observations on 3D grid</li><li><code>W⁻</code>: appropriate weighting (inverse covariance) matrix for these observations,</li><li><code>ytrue</code>: uncontaminated observations, 3D field</li><li><code>locs</code>: 3-tuples of locations for observations</li><li><code>wis</code>: weighted indices for interpolation to locs sites</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L1130-L1145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.sample_observations-Tuple{Any, Any}" href="#TMI.sample_observations-Tuple{Any, Any}"><code>TMI.sample_observations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sample_observations(TMIversion,variable)
Synthetic observations that are a contaminated version of real observations
This version: gridded observations</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion::String</code>: version of TMI water-mass/circulation model</li><li><code>variable::String</code>: variable name to use as template</li></ul><p><strong>Output</strong></p><ul><li><code>y</code>: contaminated observations on 3D grid</li><li><code>W⁻</code>: appropriate weighting (inverse covariance) matrix for these observations,</li><li><code>θtrue</code>: real observations, 3D field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L1095-L1107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.section-Tuple{Any, Any, Any}" href="#TMI.section-Tuple{Any, Any, Any}"><code>TMI.section</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function section
View latitude-depth slice of field</code></pre><p><strong>Arguments</strong></p><ul><li><code>c</code>: 3d tracer field</li><li><code>lon</code>: longitude of section</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>csection</code>: 2d slice of field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L589-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.steady_inversion-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, BitArray{3}}} where T&lt;:Real" href="#TMI.steady_inversion-Union{Tuple{T}, Tuple{Vector{T}, Any, Array{T, 3}, BitArray{3}}} where T&lt;:Real"><code>TMI.steady_inversion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function steady_inversion(u,Alu,d,γ.wet)
invert for a steady-state tracer distribution</code></pre><p><strong>Arguments</strong></p><ul><li><code>u</code>: controls, vector format</li><li><code>Alu</code>: LU decomposition of water-mass matrix</li><li><code>d</code>: model constraints</li><li><code>wet</code>: BitArray ocean mask</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>: steady-state tracer distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L1496-L1507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.surfaceindex-Tuple{Any}" href="#TMI.surfaceindex-Tuple{Any}"><code>TMI.surfaceindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function surfaceindex(I) 
Get the vector-index where depth level == 1 and it is ocean.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L692-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.surfaceorigin-Tuple{Any, Any}" href="#TMI.surfaceorigin-Tuple{Any, Any}"><code>TMI.surfaceorigin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function surfaceorigin(TMIversion,loc)
 Find the surface origin of water for some interior box 
 This is equivalent to solving a sensitivity problem:
 The mass fraction at a location `loc` of interest is 
`c[loc] = δᵀ c`, where `δ` samples the location of the global mass-fraction variable, c.
Then the sensitivity of `c[loc]` is: d(c[loc])/d(d) = A⁻ᵀ δ.
The derivative is solved using the constraint: Ac = d.
The sensitivity is exactly the mass fraction originating from each source.      
This problem is mathematically similar to determining how the ocean is filled.</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>loc</code>: location (lon,lat,depth) of location of interest</li></ul><p><strong>Output</strong></p><ul><li><code>origin</code>: surface map of fraction of source water for a given location</li><li><code>γ</code>: TMI grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L916-L933">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.surfacepatch-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, TMI.grid}} where T&lt;:Real" href="#TMI.surfacepatch-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, TMI.grid}} where T&lt;:Real"><code>TMI.surfacepatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function surfacepatch
Make a surface boundary condition
with a rectangular patch</code></pre><p><strong>Arguments</strong></p><ul><li><code>lonbox</code>: longitudes of box edges</li><li><code>latbox</code>: latitudes of box edges</li><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>d</code>: vector that describes surface patch</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L472-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.tracerinit" href="#TMI.tracerinit"><code>TMI.tracerinit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function tracerinit(wet,ltype=Float64)
  initialize tracer field on TMI grid
perhaps better to have a tracer struct and constructor</code></pre><p><strong>Arguments</strong></p><ul><li><code>wet</code>::BitArray mask of ocean points</li></ul><p><strong>Output</strong></p><ul><li><code>d</code>:: 3d tracer field with NaN on dry points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L701-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.trackpathways-Tuple{Any, Any, Any}" href="#TMI.trackpathways-Tuple{Any, Any, Any}"><code>TMI.trackpathways</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function trackpathways(TMIversion,latbox,lonbox)
Track the pathways of a user-defined water mass.
 Steps: (a) define the water mass by a rectangular surface patch dyed with passive tracer concentration of         (b) propagate the dye with the matrix A, with the result being the fraction of water originating from the surface region.
 See Section 2b of Gebbie &amp; Huybers 2010, esp. eqs. (15)-(17).</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li><li><code>latbox</code>: min and max latitude of box</li><li><code>lonbox</code>: min and max longitude of box</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>: fraction of water from surface source</li><li><code>γ</code>: TMI grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L813-L826">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.updatelinearindex-Tuple{Any, Any, Any}" href="#TMI.updatelinearindex-Tuple{Any, Any, Any}"><code>TMI.updatelinearindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function updatelinearindex(izyx,Izyx,R)
Linear index translated from z,y,x to x,y,z accounting</code></pre><p><strong>Arguments</strong></p><ul><li><code>izyx</code>: index of interest in z,y,x accounting</li><li><code>Izyx</code>: wet Cartesian Index for z,y,x</li><li><code>R</code>: Linear indices for x,y,z </li></ul><p><strong>Output</strong></p><ul><li><code>ixyz</code>: index of interest in x,y,z accounting</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L230-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.vec2fld-Tuple{Vector{Float64}, Vector{CartesianIndex{3}}}" href="#TMI.vec2fld-Tuple{Vector{Float64}, Vector{CartesianIndex{3}}}"><code>TMI.vec2fld</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function vec2fld
Transfer a vector to a 3D field with accounting for ocean bathymetry</code></pre><p><strong>Arguments</strong></p><ul><li><code>vector</code>: field in vector form (no land points)</li><li><code>I</code>: cartesian indices of ocean points</li></ul><p><strong>Output</strong></p><ul><li><code>field</code>: field in 3d form including land points (NaN)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L435-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.volumefilled-Tuple{Any}" href="#TMI.volumefilled-Tuple{Any}"><code>TMI.volumefilled</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function volumefilled(TMIversion)
Find the ocean volume that has originated from each surface box.
 This is equivalent to solving a sensitivity problem:
 The total volume is V = vᵀ c , where v is the volume of each box 
 and c is the fraction of volume from a given source which
 satisfies the equation A c = d.                     
 Next, dV/d(d) = A⁻ᵀ v, and dV/d(d) is exactly the volume originating from each source.

 See Section 3 and Supplementary Section 4, Gebbie &amp; Huybers 2011.</code></pre><p><strong>Arguments</strong></p><ul><li><code>TMIversion</code>: version of TMI water-mass/circulation model</li></ul><p><strong>Output</strong></p><ul><li><code>volume</code>: global ocean volume filled by a surface region</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L879-L894">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.watermassmatrix-Tuple{Any}" href="#TMI.watermassmatrix-Tuple{Any}"><code>TMI.watermassmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function watermassmatrix(file)
Read and assemble the water-mass matrix.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li></ul><p><strong>Output</strong></p><ul><li><code>A</code>: water-mass matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L246-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.watermassmatrixXYZ-Tuple{Any, Any}" href="#TMI.watermassmatrixXYZ-Tuple{Any, Any}"><code>TMI.watermassmatrixXYZ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    function watermassmatrixXYZ(file,R)
Read and assemble the water-mass matrix from MATLAB.
Transfer to updated x,y,z version</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li><li><code>γ</code>: TMI grid</li></ul><p><strong>Output</strong></p><ul><li><code>A</code>: water-mass matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L200-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.watermassmatrixZYX-Tuple{Any}" href="#TMI.watermassmatrixZYX-Tuple{Any}"><code>TMI.watermassmatrixZYX</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function watermassmatrixZYX(file)
Read and assemble the water-mass matrix.
Legacy version from MATLAB.</code></pre><p><strong>Arguments</strong></p><ul><li><code>file</code>: TMI NetCDF file name</li></ul><p><strong>Output</strong></p><ul><li><code>A</code>: water-mass matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L183-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TMI.wetlocation-Tuple{Any}" href="#TMI.wetlocation-Tuple{Any}"><code>TMI.wetlocation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function wetlocation(γ)
Get (lon,lat,depth) tuples of wet locations.
Allow a location to be wet if at least one out of 8 nearby gridpoints is wet.
Certainly &quot;wet&quot; gridpoints could be defined more strictly.</code></pre><p><strong>Arguments</strong></p><ul><li><code>γ</code>: TMI.grid</li></ul><p><strong>Output</strong></p><ul><li><code>loc</code>: lon,lat,depth tuple</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ggebbie/TMI.jl/blob/2295a0e3a3034c2914ca9b50b578027cb8ac9b19/src/TMI.jl#L1524-L1533">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 3 November 2021 02:27">Wednesday 3 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
